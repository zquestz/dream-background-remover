import typing

import cairo
from gi.repository import Babl
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import GdkPixbuf
from gi.repository import Gegl
from gi.repository import Gio
from gi.repository import Pango
T = typing.TypeVar("T")
_SomeSurface = typing.TypeVar("_SomeSurface", bound=cairo.Surface)

API_VERSION: str = "3.0"
CHECK_DARK: float = 0.4
CHECK_LIGHT: float = 0.6
CHECK_SIZE: int = 8
CHECK_SIZE_SM: int = 4
CONFIG_PARAM_AGGREGATE: int = 2
CONFIG_PARAM_CONFIRM: int = 8
CONFIG_PARAM_DEFAULTS: int = 16
CONFIG_PARAM_DONT_COMPARE: int = 64
CONFIG_PARAM_FLAGS: int = 7
CONFIG_PARAM_FLAG_SHIFT: int = 7
CONFIG_PARAM_IGNORE: int = 32
CONFIG_PARAM_RESTART: int = 4
CONFIG_PARAM_SERIALIZE: int = 1
MAJOR_VERSION: int = 3
MAX_IMAGE_SIZE: int = 524288
MAX_MEMSIZE: int = 0
MAX_RESOLUTION: float = 1048576.0
MICRO_VERSION: int = 4
MINOR_VERSION: int = 0
MIN_IMAGE_SIZE: int = 1
MIN_RESOLUTION: float = 0.005
MODULE_ABI_VERSION: int = 5
PARAM_DONT_SERIALIZE: int = 2
PARAM_FLAG_SHIFT: int = 2
PARAM_NO_VALIDATE: int = 1
PARAM_READABLE: int = 1
PARAM_READWRITE: int = 3
PARAM_STATIC_STRINGS: int = 224
PARAM_WRITABLE: int = 2
PARASITE_ATTACH_GRANDPARENT: int = 8388608
PARASITE_ATTACH_PARENT: int = 32768
PARASITE_GRANDPARENT_PERSISTENT: int = 0
PARASITE_GRANDPARENT_UNDOABLE: int = 0
PARASITE_PARENT_PERSISTENT: int = 0
PARASITE_PARENT_UNDOABLE: int = 0
PARASITE_PERSISTENT: int = 1
PARASITE_UNDOABLE: int = 2
PIXPIPE_MAXDIM: int = 4
VERSION: str = "3.0.4"
_namespace: str = "Gimp"
_version: str = "3.0"

def adaptive_supersample_area(x1: int, y1: int, x2: int, y2: int, max_depth: int, threshold: float, render_func: typing.Callable[..., float], put_pixel_func: typing.Callable[..., None], progress_func: typing.Callable[..., None], *progress_data: typing.Any) -> int: ...
def airbrush(drawable: Drawable, pressure: float, strokes: typing.Sequence[float]) -> bool: ...
def airbrush_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def attach_parasite(parasite: Parasite) -> bool: ...
def babl_format_get_type() -> typing.Type[typing.Any]: ...
def bilinear(x: float, y: float, values: typing.Sequence[float]) -> float: ...
def bilinear_16(x: float, y: float, values: typing.Sequence[int]) -> int: ...
def bilinear_32(x: float, y: float, values: typing.Sequence[int]) -> int: ...
def bilinear_8(x: float, y: float, values: typing.Sequence[int]) -> int: ...
def bilinear_rgb(x: float, y: float, values: typing.Sequence[float], has_alpha: bool, retvalues: typing.Sequence[float]) -> None: ...
def bind_text_domain(domain_name: str, dir_name: str) -> None: ...
def brushes_close_popup(brush_callback: str) -> bool: ...
def brushes_get_list(filter: str) -> list[Brush]: ...
def brushes_popup(brush_callback: str, popup_title: str, initial_brush: typing.Optional[Brush] = None, parent_window: typing.Optional[GLib.Bytes] = None) -> bool: ...
def brushes_refresh() -> bool: ...
def brushes_set_popup(brush_callback: str, brush: Brush) -> bool: ...
def buffer_delete(buffer_name: str) -> bool: ...
def buffer_get_bytes(buffer_name: str) -> int: ...
def buffer_get_height(buffer_name: str) -> int: ...
def buffer_get_image_type(buffer_name: str) -> ImageType: ...
def buffer_get_width(buffer_name: str) -> int: ...
def buffer_rename(buffer_name: str, new_name: str) -> str: ...
def buffers_get_name_list(filter: typing.Optional[str] = None) -> list[str]: ...
def cache_directory() -> str: ...
def cairo_checkerboard_create(cr: cairo.Context[_SomeSurface], size: int, light: Gegl.Color, dark: Gegl.Color) -> cairo.Pattern: ...
def cairo_surface_create_buffer(surface: cairo.Surface, format: Babl.Object) -> Gegl.Buffer: ...
def cairo_surface_get_format(surface: cairo.Surface) -> Babl.Object: ...
def canonicalize_identifier(identifier: str) -> str: ...
def check_custom_color1() -> Gegl.Color: ...
def check_custom_color2() -> Gegl.Color: ...
def check_size() -> CheckSize: ...
def check_type() -> CheckType: ...
def checks_get_colors(type: CheckType) -> typing.Tuple[Gegl.Color, Gegl.Color]: ...
def clone(drawable: Drawable, src_drawable: Drawable, clone_type: CloneType, src_x: float, src_y: float, strokes: typing.Sequence[float]) -> bool: ...
def clone_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def color_array_copy(array: Gegl.Color) -> Gegl.Color: ...
def color_array_free(array: Gegl.Color) -> None: ...
def color_array_get_length(array: Gegl.Color) -> int: ...
def color_array_get_type() -> typing.Type[typing.Any]: ...
def color_is_out_of_gamut(color: Gegl.Color, space: Babl.Object) -> bool: ...
def color_is_out_of_self_gamut(color: Gegl.Color) -> bool: ...
def color_is_perceptually_identical(color1: Gegl.Color, color2: Gegl.Color) -> bool: ...
def color_list_names() -> typing.Tuple[list[str], list[Gegl.Color]]: ...
def color_parse_css(css: str) -> Gegl.Color: ...
def color_parse_hex(hex: str) -> Gegl.Color: ...
def color_parse_name(name: str) -> Gegl.Color: ...
def color_set_alpha(color: Gegl.Color, alpha: float) -> None: ...
def config_build_data_path(name: str) -> str: ...
def config_build_plug_in_path(name: str) -> str: ...
def config_build_system_path(name: str) -> str: ...
def config_build_writable_path(name: str) -> str: ...
def config_deserialize_return(scanner: GLib.Scanner, expected_token: GLib.TokenType, nest_level: int) -> bool: ...
def config_diff(a: GObject.Object, b: GObject.Object, flags: GObject.ParamFlags) -> list[GObject.ParamSpec]: ...
def config_error_quark() -> int: ...
def config_param_spec_duplicate(pspec: GObject.ParamSpec) -> GObject.ParamSpec: ...
def config_reset_properties(object: GObject.Object) -> None: ...
def config_reset_property(object: GObject.Object, property_name: str) -> None: ...
def config_serialize_value(value: typing.Any, str: GLib.String, escaped: bool) -> bool: ...
def config_string_append_escaped(string: GLib.String, val: str) -> None: ...
def config_sync(src: GObject.Object, dest: GObject.Object, flags: GObject.ParamFlags) -> bool: ...
def config_type_register(parent_type: typing.Type[typing.Any], type_name: str, pspecs: typing.Sequence[GObject.ParamSpec]) -> typing.Type[typing.Any]: ...
def context_are_dynamics_enabled() -> bool: ...
def context_enable_dynamics(enable: bool) -> bool: ...
def context_get_antialias() -> bool: ...
def context_get_background() -> Gegl.Color: ...
def context_get_brush() -> Brush: ...
def context_get_brush_angle() -> float: ...
def context_get_brush_aspect_ratio() -> float: ...
def context_get_brush_force() -> float: ...
def context_get_brush_hardness() -> float: ...
def context_get_brush_size() -> float: ...
def context_get_brush_spacing() -> float: ...
def context_get_diagonal_neighbors() -> bool: ...
def context_get_distance_metric() -> Gegl.DistanceMetric: ...
def context_get_dynamics_name() -> str: ...
def context_get_emulate_brush_dynamics() -> bool: ...
def context_get_feather() -> bool: ...
def context_get_feather_radius() -> typing.Tuple[bool, float, float]: ...
def context_get_font() -> Font: ...
def context_get_foreground() -> Gegl.Color: ...
def context_get_gradient() -> Gradient: ...
def context_get_gradient_blend_color_space() -> GradientBlendColorSpace: ...
def context_get_gradient_repeat_mode() -> RepeatMode: ...
def context_get_gradient_reverse() -> bool: ...
def context_get_ink_angle() -> float: ...
def context_get_ink_blob_angle() -> float: ...
def context_get_ink_blob_aspect_ratio() -> float: ...
def context_get_ink_blob_type() -> InkBlobType: ...
def context_get_ink_size() -> float: ...
def context_get_ink_size_sensitivity() -> float: ...
def context_get_ink_speed_sensitivity() -> float: ...
def context_get_ink_tilt_sensitivity() -> float: ...
def context_get_interpolation() -> InterpolationType: ...
def context_get_line_cap_style() -> CapStyle: ...
def context_get_line_dash_offset() -> float: ...
def context_get_line_dash_pattern() -> typing.Tuple[bool, list[float]]: ...
def context_get_line_join_style() -> JoinStyle: ...
def context_get_line_miter_limit() -> float: ...
def context_get_line_width() -> float: ...
def context_get_line_width_unit() -> Unit: ...
def context_get_mypaint_brush() -> str: ...
def context_get_opacity() -> float: ...
def context_get_paint_method() -> str: ...
def context_get_paint_mode() -> LayerMode: ...
def context_get_palette() -> Palette: ...
def context_get_pattern() -> Pattern: ...
def context_get_sample_criterion() -> SelectCriterion: ...
def context_get_sample_merged() -> bool: ...
def context_get_sample_threshold() -> float: ...
def context_get_sample_threshold_int() -> int: ...
def context_get_sample_transparent() -> bool: ...
def context_get_stroke_method() -> StrokeMethod: ...
def context_get_transform_direction() -> TransformDirection: ...
def context_get_transform_resize() -> TransformResize: ...
def context_list_paint_methods() -> typing.Tuple[bool, list[str]]: ...
def context_pop() -> bool: ...
def context_push() -> bool: ...
def context_set_antialias(antialias: bool) -> bool: ...
def context_set_background(background: Gegl.Color) -> bool: ...
def context_set_brush(brush: Brush) -> bool: ...
def context_set_brush_angle(angle: float) -> bool: ...
def context_set_brush_aspect_ratio(aspect: float) -> bool: ...
def context_set_brush_default_hardness() -> bool: ...
def context_set_brush_default_size() -> bool: ...
def context_set_brush_default_spacing() -> bool: ...
def context_set_brush_force(force: float) -> bool: ...
def context_set_brush_hardness(hardness: float) -> bool: ...
def context_set_brush_size(size: float) -> bool: ...
def context_set_brush_spacing(spacing: float) -> bool: ...
def context_set_default_colors() -> bool: ...
def context_set_defaults() -> bool: ...
def context_set_diagonal_neighbors(diagonal_neighbors: bool) -> bool: ...
def context_set_distance_metric(metric: Gegl.DistanceMetric) -> bool: ...
def context_set_dynamics_name(name: str) -> bool: ...
def context_set_emulate_brush_dynamics(emulate_dynamics: bool) -> bool: ...
def context_set_feather(feather: bool) -> bool: ...
def context_set_feather_radius(feather_radius_x: float, feather_radius_y: float) -> bool: ...
def context_set_font(font: Font) -> bool: ...
def context_set_foreground(foreground: Gegl.Color) -> bool: ...
def context_set_gradient(gradient: Gradient) -> bool: ...
def context_set_gradient_blend_color_space(blend_color_space: GradientBlendColorSpace) -> bool: ...
def context_set_gradient_fg_bg_hsv_ccw() -> bool: ...
def context_set_gradient_fg_bg_hsv_cw() -> bool: ...
def context_set_gradient_fg_bg_rgb() -> bool: ...
def context_set_gradient_fg_transparent() -> bool: ...
def context_set_gradient_repeat_mode(repeat_mode: RepeatMode) -> bool: ...
def context_set_gradient_reverse(reverse: bool) -> bool: ...
def context_set_ink_angle(angle: float) -> bool: ...
def context_set_ink_blob_angle(angle: float) -> bool: ...
def context_set_ink_blob_aspect_ratio(aspect: float) -> bool: ...
def context_set_ink_blob_type(type: InkBlobType) -> bool: ...
def context_set_ink_size(size: float) -> bool: ...
def context_set_ink_size_sensitivity(size: float) -> bool: ...
def context_set_ink_speed_sensitivity(speed: float) -> bool: ...
def context_set_ink_tilt_sensitivity(tilt: float) -> bool: ...
def context_set_interpolation(interpolation: InterpolationType) -> bool: ...
def context_set_line_cap_style(cap_style: CapStyle) -> bool: ...
def context_set_line_dash_offset(dash_offset: float) -> bool: ...
def context_set_line_dash_pattern(dashes: typing.Sequence[float]) -> bool: ...
def context_set_line_join_style(join_style: JoinStyle) -> bool: ...
def context_set_line_miter_limit(miter_limit: float) -> bool: ...
def context_set_line_width(line_width: float) -> bool: ...
def context_set_line_width_unit(line_width_unit: Unit) -> bool: ...
def context_set_mypaint_brush(name: str) -> bool: ...
def context_set_opacity(opacity: float) -> bool: ...
def context_set_paint_method(name: str) -> bool: ...
def context_set_paint_mode(paint_mode: LayerMode) -> bool: ...
def context_set_palette(palette: Palette) -> bool: ...
def context_set_pattern(pattern: Pattern) -> bool: ...
def context_set_sample_criterion(sample_criterion: SelectCriterion) -> bool: ...
def context_set_sample_merged(sample_merged: bool) -> bool: ...
def context_set_sample_threshold(sample_threshold: float) -> bool: ...
def context_set_sample_threshold_int(sample_threshold: int) -> bool: ...
def context_set_sample_transparent(sample_transparent: bool) -> bool: ...
def context_set_stroke_method(stroke_method: StrokeMethod) -> bool: ...
def context_set_transform_direction(transform_direction: TransformDirection) -> bool: ...
def context_set_transform_resize(transform_resize: TransformResize) -> bool: ...
def context_swap_colors() -> bool: ...
def convolve(drawable: Drawable, pressure: float, convolve_type: ConvolveType, strokes: typing.Sequence[float]) -> bool: ...
def convolve_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def core_object_array_get_length(array: GObject.Object) -> int: ...
def core_object_array_get_type() -> typing.Type[typing.Any]: ...
def data_directory() -> str: ...
def debug_timer_end() -> float: ...
def debug_timer_start() -> bool: ...
def default_display() -> Display: ...
def detach_parasite(name: str) -> bool: ...
def directory() -> str: ...
def displays_flush() -> bool: ...
def displays_reconnect(old_image: Image, new_image: Image) -> bool: ...
def dodgeburn(drawable: Drawable, exposure: float, dodgeburn_type: DodgeBurnType, dodgeburn_mode: TransferMode, strokes: typing.Sequence[float]) -> bool: ...
def dodgeburn_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def double_array_get_values(array: Array) -> list[float]: ...
def double_array_set_values(array: Array, values: typing.Sequence[float], static_data: bool) -> None: ...
def drawables_close_popup(callback: str) -> bool: ...
def drawables_popup(callback: str, popup_title: str, drawable_type: str, initial_drawable: typing.Optional[Drawable] = None, parent_window: typing.Optional[GLib.Bytes] = None) -> bool: ...
def drawables_set_popup(callback: str, drawable: Drawable) -> bool: ...
def dynamics_get_name_list(filter: typing.Optional[str] = None) -> list[str]: ...
def dynamics_refresh() -> bool: ...
def edit_copy(drawables: typing.Sequence[Drawable]) -> bool: ...
def edit_copy_visible(image: Image) -> bool: ...
def edit_cut(drawables: typing.Sequence[Drawable]) -> bool: ...
def edit_named_copy(drawables: typing.Sequence[Drawable], buffer_name: str) -> str: ...
def edit_named_copy_visible(image: Image, buffer_name: str) -> str: ...
def edit_named_cut(drawables: typing.Sequence[Drawable], buffer_name: str) -> str: ...
def edit_named_paste(drawable: Drawable, buffer_name: str, paste_into: bool) -> Layer: ...
def edit_named_paste_as_new_image(buffer_name: str) -> Image: ...
def edit_paste(drawable: Drawable, paste_into: bool) -> list[Drawable]: ...
def edit_paste_as_new_image() -> Image: ...
def enum_get_desc(enum_class: GObject.EnumClass, value: int) -> typing.Optional[EnumDesc]: ...
def enum_get_value(enum_type: typing.Type[typing.Any], value: int) -> typing.Tuple[bool, str, str, str, str]: ...
def enum_get_value_descriptions(enum_type: typing.Type[typing.Any]) -> EnumDesc: ...
def enum_set_value_descriptions(enum_type: typing.Type[typing.Any], descriptions: EnumDesc) -> None: ...
def enum_value_get_abbrev(enum_class: GObject.EnumClass, enum_value: GObject.EnumValue) -> str: ...
def enum_value_get_desc(enum_class: GObject.EnumClass, enum_value: GObject.EnumValue) -> str: ...
def enum_value_get_help(enum_class: GObject.EnumClass, enum_value: GObject.EnumValue) -> str: ...
def enums_get_type_names() -> list[str]: ...
def enums_init() -> None: ...
def eraser(drawable: Drawable, strokes: typing.Sequence[float], hardness: BrushApplicationMode, method: PaintApplicationMode) -> bool: ...
def eraser_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def escape_uline(str: typing.Optional[str] = None) -> str: ...
def export_color_profile() -> bool: ...
def export_comment() -> bool: ...
def export_exif() -> bool: ...
def export_iptc() -> bool: ...
def export_thumbnail() -> bool: ...
def export_xmp() -> bool: ...
def file_create_thumbnail(image: Image, file: Gio.File) -> bool: ...
def file_get_config_path(file: Gio.File) -> str: ...
def file_get_utf8_name(file: Gio.File) -> str: ...
def file_has_extension(file: Gio.File, extension: str) -> bool: ...
def file_load(run_mode: RunMode, file: Gio.File) -> Image: ...
def file_load_layer(run_mode: RunMode, image: Image, file: Gio.File) -> Layer: ...
def file_load_layers(run_mode: RunMode, image: Image, file: Gio.File) -> list[Layer]: ...
def file_new_for_config_path(path: str) -> typing.Optional[Gio.File]: ...
def file_save(run_mode: RunMode, image: Image, file: Gio.File, options: typing.Optional[ExportOptions] = None) -> bool: ...
def file_show_in_file_manager(file: Gio.File) -> bool: ...
def filename_to_utf8(filename: str) -> str: ...
def flags_get_first_desc(flags_class: GObject.FlagsClass, value: int) -> typing.Optional[FlagsDesc]: ...
def flags_get_first_value(flags_type: typing.Type[typing.Any], value: int) -> typing.Tuple[bool, str, str, str, str]: ...
def flags_get_value_descriptions(flags_type: typing.Type[typing.Any]) -> FlagsDesc: ...
def flags_set_value_descriptions(flags_type: typing.Type[typing.Any], descriptions: FlagsDesc) -> None: ...
def flags_value_get_abbrev(flags_class: GObject.FlagsClass, flags_value: GObject.FlagsValue) -> str: ...
def flags_value_get_desc(flags_class: GObject.FlagsClass, flags_value: GObject.FlagsValue) -> str: ...
def flags_value_get_help(flags_class: GObject.FlagsClass, flags_value: GObject.FlagsValue) -> str: ...
def floating_sel_anchor(floating_sel: Layer) -> bool: ...
def floating_sel_attach(layer: Layer, drawable: Drawable) -> bool: ...
def floating_sel_remove(floating_sel: Layer) -> bool: ...
def floating_sel_to_layer(floating_sel: Layer) -> bool: ...
def fonts_close_popup(font_callback: str) -> bool: ...
def fonts_get_list(filter: typing.Optional[str] = None) -> list[Font]: ...
def fonts_popup(font_callback: str, popup_title: str, initial_font: typing.Optional[Font] = None, parent_window: typing.Optional[GLib.Bytes] = None) -> bool: ...
def fonts_refresh() -> bool: ...
def fonts_set_popup(font_callback: str, font: Font) -> bool: ...
def get_color_configuration() -> ColorConfig: ...
def get_default_comment() -> str: ...
def get_default_unit() -> Unit: ...
def get_images() -> list[Image]: ...
def get_module_load_inhibit() -> str: ...
def get_monitor_resolution() -> typing.Tuple[bool, float, float]: ...
def get_num_processors() -> int: ...
def get_parasite(name: str) -> Parasite: ...
def get_parasite_list() -> list[str]: ...
def get_pdb() -> typing.Optional[PDB]: ...
def get_plug_in() -> typing.Optional[PlugIn]: ...
def get_progname() -> str: ...
def getpid() -> int: ...
def gimprc_query(token: str) -> str: ...
def gimprc_set(token: str, value: str) -> bool: ...
def gradients_close_popup(gradient_callback: str) -> bool: ...
def gradients_get_list(filter: typing.Optional[str] = None) -> list[Gradient]: ...
def gradients_popup(gradient_callback: str, popup_title: str, initial_gradient: typing.Optional[Gradient] = None, parent_window: typing.Optional[GLib.Bytes] = None) -> bool: ...
def gradients_refresh() -> bool: ...
def gradients_set_popup(gradient_callback: str, gradient: Gradient) -> bool: ...
def heal(drawable: Drawable, src_drawable: Drawable, src_x: float, src_y: float, strokes: typing.Sequence[float]) -> bool: ...
def heal_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def help(help_domain: typing.Optional[str], help_id: str) -> bool: ...
def icon_theme_dir() -> str: ...
def installation_directory() -> str: ...
def int32_array_get_values(array: Array) -> list[int]: ...
def int32_array_set_values(array: Array, values: typing.Sequence[int], static_data: bool) -> None: ...
def is_canonical_identifier(identifier: str) -> bool: ...
def locale_directory() -> str: ...
def main(plug_in_type: typing.Type[typing.Any], argv: typing.Sequence[str]) -> int: ...
def message(message: str) -> bool: ...
def message_get_handler() -> MessageHandlerType: ...
def message_set_handler(handler: MessageHandlerType) -> bool: ...
def monitor_number() -> int: ...
def paintbrush(drawable: Drawable, fade_out: float, strokes: typing.Sequence[float], method: PaintApplicationMode, gradient_length: float) -> bool: ...
def paintbrush_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def palettes_close_popup(palette_callback: str) -> bool: ...
def palettes_get_list(filter: typing.Optional[str] = None) -> list[Palette]: ...
def palettes_popup(palette_callback: str, popup_title: str, initial_palette: typing.Optional[Palette] = None, parent_window: typing.Optional[GLib.Bytes] = None) -> bool: ...
def palettes_refresh() -> bool: ...
def palettes_set_popup(palette_callback: str, palette: Palette) -> bool: ...
def param_spec_array(name: str, nick: str, blurb: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_brush(name: str, nick: str, blurb: str, none_ok: bool, default_value: typing.Optional[Brush], default_to_context: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_channel(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_choice(name: str, nick: str, blurb: str, choice: Choice, default_value: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_choice_get_choice(pspec: GObject.ParamSpec) -> Choice: ...
def param_spec_choice_get_default(pspec: GObject.ParamSpec) -> str: ...
def param_spec_color(name: str, nick: str, blurb: str, has_alpha: bool, default_color: Gegl.Color, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_color_from_string(name: str, nick: str, blurb: str, has_alpha: bool, default_color_string: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_color_has_alpha(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_config_path(name: str, nick: str, blurb: str, type: ConfigPathType, default_value: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_config_path_type(pspec: GObject.ParamSpec) -> ConfigPathType: ...
def param_spec_core_object_array(name: str, nick: str, blurb: str, object_type: typing.Type[typing.Any], flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_core_object_array_get_object_type(pspec: GObject.ParamSpec) -> typing.Type[typing.Any]: ...
def param_spec_display(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_display_none_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_double_array(name: str, nick: str, blurb: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_drawable(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_drawable_filter(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_drawable_filter_none_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_export_options(name: str, nick: str, blurb: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_file(name: str, nick: str, blurb: str, action: FileChooserAction, none_ok: bool, default_value: typing.Optional[Gio.File], flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_file_get_action(pspec: GObject.ParamSpec) -> FileChooserAction: ...
def param_spec_file_none_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_file_set_action(pspec: GObject.ParamSpec, action: FileChooserAction) -> None: ...
def param_spec_font(name: str, nick: str, blurb: str, none_ok: bool, default_value: typing.Optional[Font], default_to_context: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_gradient(name: str, nick: str, blurb: str, none_ok: bool, default_value: typing.Optional[Gradient], default_to_context: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_group_layer(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_image(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_image_none_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_int32_array(name: str, nick: str, blurb: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_item(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_item_none_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_layer(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_layer_mask(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_matrix2(name: str, nick: str, blurb: str, default_value: Matrix2, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_matrix3(name: str, nick: str, blurb: str, default_value: Matrix3, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_memsize(name: str, nick: str, blurb: str, minimum: int, maximum: int, default_value: int, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_object_duplicate(pspec: GObject.ParamSpec) -> GObject.ParamSpec: ...
def param_spec_object_get_default(pspec: GObject.ParamSpec) -> GObject.Object: ...
def param_spec_object_has_default(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_object_set_default(pspec: GObject.ParamSpec, default_value: typing.Optional[GObject.Object] = None) -> None: ...
def param_spec_palette(name: str, nick: str, blurb: str, none_ok: bool, default_value: typing.Optional[Palette], default_to_context: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_parasite(name: str, nick: str, blurb: str, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_path(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_pattern(name: str, nick: str, blurb: str, none_ok: bool, default_value: typing.Optional[Pattern], default_to_context: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_resource(name: str, nick: str, blurb: str, resource_type: typing.Type[typing.Any], none_ok: bool, default_value: typing.Optional[Resource], default_to_context: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_resource_defaults_to_context(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_resource_none_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_selection(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_text_layer(name: str, nick: str, blurb: str, none_ok: bool, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_unit(name: str, nick: str, blurb: str, allow_pixel: bool, allow_percent: bool, default_value: Unit, flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_unit_percent_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_unit_pixel_allowed(pspec: GObject.ParamSpec) -> bool: ...
def param_spec_value_array(name: str, nick: str, blurb: str, element_spec: typing.Optional[GObject.ParamSpec], flags: GObject.ParamFlags) -> GObject.ParamSpec: ...
def param_spec_value_array_get_element_spec(pspec: GObject.ParamSpec) -> GObject.ParamSpec: ...
def patterns_close_popup(pattern_callback: str) -> bool: ...
def patterns_get_list(filter: typing.Optional[str] = None) -> list[Pattern]: ...
def patterns_popup(pattern_callback: str, popup_title: str, initial_pattern: typing.Optional[Pattern] = None, parent_window: typing.Optional[GLib.Bytes] = None) -> bool: ...
def patterns_refresh() -> bool: ...
def patterns_set_popup(pattern_callback: str, pattern: Pattern) -> bool: ...
def pencil(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def pixbuf_create_buffer(pixbuf: GdkPixbuf.Pixbuf) -> Gegl.Buffer: ...
def pixbuf_get_format(pixbuf: GdkPixbuf.Pixbuf) -> Babl.Object: ...
def pixbuf_get_icc_profile(pixbuf: GdkPixbuf.Pixbuf) -> typing.Optional[bytes]: ...
def pixels_to_units(pixels: float, unit: Unit, resolution: float) -> float: ...
def pixpipe_params_build(params: PixPipeParams) -> str: ...
def pixpipe_params_free(params: PixPipeParams) -> None: ...
def pixpipe_params_init(params: PixPipeParams) -> None: ...
def pixpipe_params_parse(parameters: str, params: PixPipeParams) -> None: ...
def progress_cancel(progress_callback: str) -> bool: ...
def progress_end() -> bool: ...
def progress_get_window_handle() -> GLib.Bytes: ...
def progress_init(message: str) -> bool: ...
def progress_install_vtable(vtable: ProgressVtable, user_data: None, user_data_destroy: typing.Optional[typing.Callable[[None], None]] = None) -> str: ...
def progress_pulse() -> bool: ...
def progress_set_text(message: typing.Optional[str] = None) -> bool: ...
def progress_uninstall(progress_callback: str) -> None: ...
def progress_update(percentage: float) -> bool: ...
def quit() -> None: ...
def range_estimate_settings(lower: float, upper: float) -> typing.Tuple[float, float, int]: ...
def rectangle_intersect(x1: int, y1: int, width1: int, height1: int, x2: int, y2: int, width2: int, height2: int) -> typing.Tuple[bool, int, int, int, int]: ...
def rectangle_union(x1: int, y1: int, width1: int, height1: int, x2: int, y2: int, width2: int, height2: int) -> typing.Tuple[int, int, int, int]: ...
def show_help_button() -> bool: ...
def smudge(drawable: Drawable, pressure: float, strokes: typing.Sequence[float]) -> bool: ...
def smudge_default(drawable: Drawable, strokes: typing.Sequence[float]) -> bool: ...
def stack_trace_available(optimal: bool) -> bool: ...
def stack_trace_print(prog_name: str, stream: None) -> typing.Tuple[bool, str]: ...
def stack_trace_query(prog_name: str) -> None: ...
def strip_uline(str: typing.Optional[str] = None) -> str: ...
def sysconf_directory() -> str: ...
def temp_directory() -> str: ...
def temp_file(extension: typing.Optional[str] = None) -> Gio.File: ...
def text_font(image: Image, drawable: typing.Optional[Drawable], x: float, y: float, text: str, border: int, antialias: bool, size: float, font: Font) -> typing.Optional[Layer]: ...
def text_get_extents_font(text: str, size: float, font: Font) -> typing.Tuple[bool, int, int, int, int]: ...
def tile_height() -> int: ...
def tile_width() -> int: ...
def type_get_translation_context(type: typing.Type[typing.Any]) -> str: ...
def type_get_translation_domain(type: typing.Type[typing.Any]) -> str: ...
def type_set_translation_context(type: typing.Type[typing.Any], context: str) -> None: ...
def type_set_translation_domain(type: typing.Type[typing.Any], domain: str) -> None: ...
def units_to_pixels(value: float, unit: Unit, resolution: float) -> float: ...
def units_to_points(value: float, unit: Unit, resolution: float) -> float: ...
def user_time() -> int: ...
def utf8_strtrim(str: typing.Optional[str], max_chars: int) -> str: ...
def value_dup_double_array(value: typing.Any) -> list[float]: ...
def value_dup_int32_array(value: typing.Any) -> list[int]: ...
def value_get_double_array(value: typing.Any) -> list[float]: ...
def value_get_int32_array(value: typing.Any) -> list[int]: ...
def value_set_double_array(value: typing.Any, data: typing.Sequence[float]) -> None: ...
def value_set_int32_array(value: typing.Any, data: typing.Sequence[int]) -> None: ...
def value_set_static_double_array(value: typing.Any, data: typing.Sequence[float]) -> None: ...
def value_set_static_int32_array(value: typing.Any, data: typing.Sequence[int]) -> None: ...
def value_take_double_array(value: typing.Any, data: typing.Sequence[float]) -> None: ...
def value_take_int32_array(value: typing.Any, data: typing.Sequence[int]) -> None: ...
def vector2_add(vector1: Vector2, vector2: Vector2) -> Vector2: ...
def vector2_sub(vector1: Vector2, vector2: Vector2) -> Vector2: ...
def vector3_add(vector1: Vector3, vector2: Vector3) -> Vector3: ...
def vector3_sub(vector1: Vector3, vector2: Vector3) -> Vector3: ...
def vector_2d_to_3d(sx: int, sy: int, w: int, h: int, x: int, y: int, vp: Vector3, p: Vector3) -> None: ...
def vector_2d_to_3d_val(sx: int, sy: int, w: int, h: int, x: int, y: int, vp: Vector3, p: Vector3) -> Vector3: ...
def vector_3d_to_2d(sx: int, sy: int, w: int, h: int, vp: Vector3, p: Vector3) -> typing.Tuple[float, float]: ...
def version() -> str: ...
def wm_class() -> str: ...

class Array(GObject.GBoxed):
    """
    :Constructors:

    ::

        Array()
        new(data:list, static_data:bool) -> Gimp.Array
    """
    data: bytes = ...
    length: int = ...
    static_data: bool = ...
    def copy(self) -> Array: ...
    def free(self) -> None: ...
    @classmethod
    def new(cls, data: typing.Sequence[int], static_data: bool) -> Array: ...


class BatchProcedure(Procedure):
    """
    :Constructors:

    ::

        BatchProcedure(**properties)
        new(plug_in:Gimp.PlugIn, name:str, interpreter_name:str, proc_type:Gimp.PDBProcType, run_func:Gimp.BatchFunc, run_data=None) -> Gimp.Procedure

    Object GimpBatchProcedure

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    def __init__(self, name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    def get_interpreter_name(self) -> str: ...
    @classmethod
    def new(cls, plug_in: PlugIn, name: str, interpreter_name: str, proc_type: PDBProcType, run_func: typing.Callable[..., ValueArray], *run_data: typing.Any) -> BatchProcedure: ...
    def set_interpreter_name(self, interpreter_name: str) -> None: ...


class BatchProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        BatchProcedureClass()
    """
    parent_class: ProcedureClass = ...

class Brush(Resource, ConfigInterface):
    """
    :Constructors:

    ::

        Brush(**properties)
        new(name:str) -> Gimp.Brush

    Object GimpBrush

    Properties from GimpResource:
      id -> gint: The id
        The id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def get_angle(self) -> typing.Tuple[bool, float]: ...
    def get_aspect_ratio(self) -> typing.Tuple[bool, float]: ...
    def get_buffer(self, max_width: int, max_height: int, format: Babl.Object) -> Gegl.Buffer: ...
    @staticmethod
    def get_by_name(name: str) -> typing.Optional[Brush]: ...
    def get_hardness(self) -> typing.Tuple[bool, float]: ...
    def get_info(self) -> typing.Tuple[bool, int, int, int, int]: ...
    def get_mask(self, max_width: int, max_height: int, format: Babl.Object) -> Gegl.Buffer: ...
    def get_radius(self) -> typing.Tuple[bool, float]: ...
    def get_shape(self) -> typing.Tuple[bool, BrushGeneratedShape]: ...
    def get_spacing(self) -> int: ...
    def get_spikes(self) -> typing.Tuple[bool, int]: ...
    def is_generated(self) -> bool: ...
    @classmethod
    def new(cls, name: str) -> Brush: ...
    def set_angle(self, angle_in: float) -> typing.Tuple[bool, float]: ...
    def set_aspect_ratio(self, aspect_ratio_in: float) -> typing.Tuple[bool, float]: ...
    def set_hardness(self, hardness_in: float) -> typing.Tuple[bool, float]: ...
    def set_radius(self, radius_in: float) -> typing.Tuple[bool, float]: ...
    def set_shape(self, shape_in: BrushGeneratedShape) -> typing.Tuple[bool, BrushGeneratedShape]: ...
    def set_spacing(self, spacing: int) -> bool: ...
    def set_spikes(self, spikes_in: int) -> typing.Tuple[bool, int]: ...


class BrushClass(GObject.GPointer):
    """
    :Constructors:

    ::

        BrushClass()
    """
    parent_class: ResourceClass = ...

class Channel(Drawable):
    """
    :Constructors:

    ::

        Channel(**properties)
        new(image:Gimp.Image, name:str, width:int, height:int, opacity:float, color:Gegl.Color) -> Gimp.Channel
        new_from_component(image:Gimp.Image, component:Gimp.ChannelType, name:str) -> Gimp.Channel

    Object GimpChannel

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    parent_instance: Drawable = ...
    def __init__(self, id: int = ...) -> None: ...
    def combine_masks(self, channel2: Channel, operation: ChannelOps, offx: int, offy: int) -> bool: ...
    def copy(self) -> Channel: ...
    @staticmethod
    def get_by_id(channel_id: int) -> typing.Optional[Channel]: ...
    def get_color(self) -> Gegl.Color: ...
    def get_opacity(self) -> float: ...
    def get_show_masked(self) -> bool: ...
    @classmethod
    def new(cls, image: Image, name: str, width: int, height: int, opacity: float, color: Gegl.Color) -> Channel: ...
    @classmethod
    def new_from_component(cls, image: Image, component: ChannelType, name: str) -> Channel: ...
    def set_color(self, color: Gegl.Color) -> bool: ...
    def set_opacity(self, opacity: float) -> bool: ...
    def set_show_masked(self, show_masked: bool) -> bool: ...


class ChannelClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ChannelClass()
    """
    parent_class: DrawableClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class Choice(GObject.Object):
    """
    :Constructors:

    ::

        Choice(**properties)
        new() -> Gimp.Choice

    Object GimpChoice

    Signals from GimpChoice:
      sensitivity-changed (gchararray)

    Signals from GObject:
      notify (GParam)
    """
    def add(self, nick: str, id: int, label: str, help: str) -> None: ...
    def get_documentation(self, nick: str, label: str, help: str) -> bool: ...
    def get_help(self, nick: str) -> str: ...
    def get_id(self, nick: str) -> int: ...
    def get_label(self, nick: str) -> str: ...
    def is_valid(self, nick: str) -> bool: ...
    def list_nicks(self) -> list[str]: ...
    @classmethod
    def new(cls) -> Choice: ...
    def set_sensitive(self, nick: str, sensitive: bool) -> None: ...


class ChoiceClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ChoiceClass()
    """
    parent_class: GObject.ObjectClass = ...

class ColorConfig(GObject.Object, ConfigInterface):
    """
    :Constructors:

    ::

        ColorConfig(**properties)

    Object GimpColorConfig

    Properties from GimpColorConfig:
      mode -> GimpColorManagementMode: Mode of operation
        How images are displayed on screen.
      rgb-profile -> GimpConfigPath: Preferred RGB profile
        The preferred RGB working space color profile. It will be offered next to the built-in RGB profile when a color profile can be chosen.
      gray-profile -> GimpConfigPath: Preferred grayscale profile
        The preferred grayscale working space color profile. It will be offered next to the built-in grayscale profile when a color profile can be chosen.
      cmyk-profile -> GimpConfigPath: CMYK profile
        The CMYK color profile used to convert between RGB and CMYK.
      display-profile -> GimpConfigPath: Monitor profile
        The color profile of your (primary) monitor.
      display-profile-from-gdk -> gboolean: Use the system monitor profile
        When enabled, GIMP will try to use the display color profile from the windowing system.  The configured monitor profile is then only used as a fallback.
      simulation-profile -> GimpConfigPath: Simulation profile for soft-proofing
        The color profile to use for soft-proofing from your image's color space to some other color space, including soft-proofing to a printer or other output device profile.
      display-rendering-intent -> GimpColorRenderingIntent: Display rendering intent
        How colors are converted from your image's color space to your display device. Relative colorimetric is usually the best choice. Unless you use a LUT monitor profile (most monitor profiles are matrix), choosing perceptual intent really gives you relative colorimetric.
      display-use-black-point-compensation -> gboolean: Use black point compensation for the display
        Do use black point compensation (unless you know you have a reason not to).
      display-optimize -> gboolean: Optimize display color transformations
        When disabled, image display might be of better quality at the cost of speed.
      simulation-rendering-intent -> GimpColorRenderingIntent: Soft-proofing rendering intent
        How colors are converted from your image's color space to the output simulation device (usually your monitor). Try them all and choose what looks the best.
      simulation-use-black-point-compensation -> gboolean: Use black point compensation for soft-proofing
        Try with and without black point compensation and choose what looks best.
      simulation-optimize -> gboolean: Optimize soft-proofing color transformations
        When disabled, soft-proofing might be of better quality at the cost of speed.
      simulation-gamut-check -> gboolean: Mark out of gamut colors
        When enabled, the soft-proofing will mark colors which can not be represented in the target color space.
      out-of-gamut-color -> GeglColor: Out of gamut warning color
        The color to use for marking colors which are out of gamut.
      show-rgb-u8 -> gboolean: Show RGB 0..255
        Show RGB 0..255 scales
      show-hsv -> gboolean: Show HSV
        Show HSV instead of LCH

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        cmyk_profile: ConfigPath
        display_optimize: bool
        display_profile: ConfigPath
        display_profile_from_gdk: bool
        display_rendering_intent: ColorRenderingIntent
        display_use_black_point_compensation: bool
        gray_profile: ConfigPath
        mode: ColorManagementMode
        out_of_gamut_color: Gegl.Color
        rgb_profile: ConfigPath
        show_hsv: bool
        show_rgb_u8: bool
        simulation_gamut_check: bool
        simulation_optimize: bool
        simulation_profile: ConfigPath
        simulation_rendering_intent: ColorRenderingIntent
        simulation_use_black_point_compensation: bool
    props: Props = ...
    def __init__(self, cmyk_profile: ConfigPath = ...,
                 display_optimize: bool = ...,
                 display_profile: ConfigPath = ...,
                 display_profile_from_gdk: bool = ...,
                 display_rendering_intent: ColorRenderingIntent = ...,
                 display_use_black_point_compensation: bool = ...,
                 gray_profile: ConfigPath = ...,
                 mode: ColorManagementMode = ...,
                 out_of_gamut_color: Gegl.Color = ...,
                 rgb_profile: ConfigPath = ...,
                 show_hsv: bool = ...,
                 show_rgb_u8: bool = ...,
                 simulation_gamut_check: bool = ...,
                 simulation_optimize: bool = ...,
                 simulation_profile: ConfigPath = ...,
                 simulation_rendering_intent: ColorRenderingIntent = ...,
                 simulation_use_black_point_compensation: bool = ...) -> None: ...
    def get_cmyk_color_profile(self) -> ColorProfile: ...
    def get_display_bpc(self) -> bool: ...
    def get_display_color_profile(self) -> ColorProfile: ...
    def get_display_intent(self) -> ColorRenderingIntent: ...
    def get_display_optimize(self) -> bool: ...
    def get_display_profile_from_gdk(self) -> bool: ...
    def get_gray_color_profile(self) -> ColorProfile: ...
    def get_mode(self) -> ColorManagementMode: ...
    def get_out_of_gamut_color(self) -> Gegl.Color: ...
    def get_rgb_color_profile(self) -> ColorProfile: ...
    def get_simulation_bpc(self) -> bool: ...
    def get_simulation_color_profile(self) -> ColorProfile: ...
    def get_simulation_gamut_check(self) -> bool: ...
    def get_simulation_intent(self) -> ColorRenderingIntent: ...
    def get_simulation_optimize(self) -> bool: ...


class ColorConfigClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ColorConfigClass()
    """
    parent_class: GObject.ObjectClass = ...

class ColorManaged(GObject.GInterface):
    """
    Interface GimpColorManaged

    Signals from GObject:
      notify (GParam)
    """
    def get_color_profile(self) -> ColorProfile: ...
    def get_icc_profile(self) -> bytes: ...
    def get_simulation_bpc(self) -> bool: ...
    def get_simulation_intent(self) -> ColorRenderingIntent: ...
    def get_simulation_profile(self) -> ColorProfile: ...
    def profile_changed(self) -> None: ...
    def simulation_bpc_changed(self) -> None: ...
    def simulation_intent_changed(self) -> None: ...
    def simulation_profile_changed(self) -> None: ...


class ColorManagedInterface(GObject.GPointer):
    """
    :Constructors:

    ::

        ColorManagedInterface()
    """
    base_iface: GObject.TypeInterface = ...
    get_icc_profile: typing.Callable[[ColorManaged], bytes] = ...
    profile_changed: typing.Callable[[ColorManaged], None] = ...
    simulation_profile_changed: typing.Callable[[ColorManaged], None] = ...
    simulation_intent_changed: typing.Callable[[ColorManaged], None] = ...
    simulation_bpc_changed: typing.Callable[[ColorManaged], None] = ...
    get_color_profile: typing.Callable[[ColorManaged], ColorProfile] = ...
    get_simulation_profile: typing.Callable[[ColorManaged], ColorProfile] = ...
    get_simulation_intent: typing.Callable[[ColorManaged], ColorRenderingIntent] = ...
    get_simulation_bpc: typing.Callable[[ColorManaged], bool] = ...

class ColorProfile(GObject.Object):
    """
    :Constructors:

    ::

        ColorProfile(**properties)
        new_d50_gray_lab_trc() -> Gimp.ColorProfile
        new_d65_gray_linear() -> Gimp.ColorProfile
        new_d65_gray_srgb_trc() -> Gimp.ColorProfile
        new_from_file(file:Gio.File) -> Gimp.ColorProfile or None
        new_from_icc_profile(data:list) -> Gimp.ColorProfile or None
        new_from_lcms_profile(lcms_profile=None) -> Gimp.ColorProfile or None
        new_rgb_adobe() -> Gimp.ColorProfile
        new_rgb_srgb() -> Gimp.ColorProfile
        new_rgb_srgb_linear() -> Gimp.ColorProfile

    Object GimpColorProfile

    Signals from GObject:
      notify (GParam)
    """
    def get_copyright(self) -> str: ...
    def get_description(self) -> str: ...
    def get_format(self, format: Babl.Object, intent: ColorRenderingIntent) -> Babl.Object: ...
    def get_icc_profile(self) -> bytes: ...
    def get_label(self) -> str: ...
    @staticmethod
    def get_lcms_format(format: Babl.Object) -> typing.Tuple[typing.Optional[Babl.Object], int]: ...
    def get_lcms_profile(self) -> None: ...
    def get_manufacturer(self) -> str: ...
    def get_model(self) -> str: ...
    def get_space(self, intent: ColorRenderingIntent) -> Babl.Object: ...
    def get_summary(self) -> str: ...
    def is_cmyk(self) -> bool: ...
    def is_equal(self, profile2: ColorProfile) -> bool: ...
    def is_gray(self) -> bool: ...
    def is_linear(self) -> bool: ...
    def is_rgb(self) -> bool: ...
    @classmethod
    def new_d50_gray_lab_trc(cls) -> ColorProfile: ...
    @classmethod
    def new_d65_gray_linear(cls) -> ColorProfile: ...
    @classmethod
    def new_d65_gray_srgb_trc(cls) -> ColorProfile: ...
    @classmethod
    def new_from_file(cls, file: Gio.File) -> typing.Optional[ColorProfile]: ...
    @classmethod
    def new_from_icc_profile(cls, data: typing.Sequence[int]) -> typing.Optional[ColorProfile]: ...
    @classmethod
    def new_from_lcms_profile(cls, lcms_profile: None) -> typing.Optional[ColorProfile]: ...
    def new_linear_from_color_profile(self) -> typing.Optional[ColorProfile]: ...
    @classmethod
    def new_rgb_adobe(cls) -> ColorProfile: ...
    @classmethod
    def new_rgb_srgb(cls) -> ColorProfile: ...
    @classmethod
    def new_rgb_srgb_linear(cls) -> ColorProfile: ...
    def new_srgb_trc_from_color_profile(self) -> typing.Optional[ColorProfile]: ...
    def save_to_file(self, file: Gio.File) -> bool: ...


class ColorProfileClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ColorProfileClass()
    """
    parent_class: GObject.ObjectClass = ...

class ColorTransform(GObject.Object):
    """
    :Constructors:

    ::

        ColorTransform(**properties)
        new(src_profile:Gimp.ColorProfile, src_format:Babl.Object, dest_profile:Gimp.ColorProfile, dest_format:Babl.Object, rendering_intent:Gimp.ColorRenderingIntent, flags:Gimp.ColorTransformFlags) -> Gimp.ColorTransform or None
        new_proofing(src_profile:Gimp.ColorProfile, src_format:Babl.Object, dest_profile:Gimp.ColorProfile, dest_format:Babl.Object, proof_profile:Gimp.ColorProfile, proof_intent:Gimp.ColorRenderingIntent, display_intent:Gimp.ColorRenderingIntent, flags:Gimp.ColorTransformFlags) -> Gimp.ColorTransform or None

    Object GimpColorTransform

    Signals from GimpColorTransform:
      progress (gdouble)

    Signals from GObject:
      notify (GParam)
    """
    @staticmethod
    def can_gegl_copy(src_profile: ColorProfile, dest_profile: ColorProfile) -> bool: ...
    @classmethod
    def new(cls, src_profile: ColorProfile, src_format: Babl.Object, dest_profile: ColorProfile, dest_format: Babl.Object, rendering_intent: ColorRenderingIntent, flags: ColorTransformFlags) -> typing.Optional[ColorTransform]: ...
    @classmethod
    def new_proofing(cls, src_profile: ColorProfile, src_format: Babl.Object, dest_profile: ColorProfile, dest_format: Babl.Object, proof_profile: ColorProfile, proof_intent: ColorRenderingIntent, display_intent: ColorRenderingIntent, flags: ColorTransformFlags) -> typing.Optional[ColorTransform]: ...
    def process_buffer(self, src_buffer: Gegl.Buffer, src_rect: Gegl.Rectangle, dest_buffer: Gegl.Buffer, dest_rect: Gegl.Rectangle) -> None: ...
    def process_pixels(self, src_format: Babl.Object, src_pixels: None, dest_format: Babl.Object, dest_pixels: None, length: int) -> None: ...


class ColorTransformClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ColorTransformClass()
    """
    parent_class: GObject.ObjectClass = ...

class Config(GObject.GPointer):
    def copy(self, dest: Config, flags: GObject.ParamFlags) -> bool: ...
    def deserialize(self, scanner: GLib.Scanner, nest_level: int, data: None) -> bool: ...
    def deserialize_file(self, file: Gio.File, data: None) -> bool: ...
    def deserialize_parasite(self, parasite: Parasite, data: None) -> bool: ...
    def deserialize_properties(self, scanner: GLib.Scanner, nest_level: int) -> bool: ...
    def deserialize_property(self, scanner: GLib.Scanner, nest_level: int) -> GLib.TokenType: ...
    def deserialize_stream(self, input: Gio.InputStream, data: None) -> bool: ...
    def deserialize_string(self, text: typing.Sequence[str], data: None) -> bool: ...
    def duplicate(self) -> None: ...
    def is_equal_to(self, b: Config) -> bool: ...
    def reset(self) -> None: ...
    def serialize(self, writer: ConfigWriter, data: None) -> bool: ...
    def serialize_changed_properties(self, writer: ConfigWriter) -> bool: ...
    def serialize_properties(self, writer: ConfigWriter) -> bool: ...
    def serialize_property(self, param_spec: GObject.ParamSpec, writer: ConfigWriter) -> bool: ...
    def serialize_property_by_name(self, prop_name: str, writer: ConfigWriter) -> bool: ...
    def serialize_to_fd(self, fd: int, data: None) -> bool: ...
    def serialize_to_file(self, file: Gio.File, header: typing.Optional[str], footer: typing.Optional[str], data: None) -> bool: ...
    def serialize_to_parasite(self, parasite_name: str, parasite_flags: int, data: None) -> Parasite: ...
    def serialize_to_stream(self, output: Gio.OutputStream, header: typing.Optional[str], footer: typing.Optional[str], data: None) -> bool: ...
    def serialize_to_string(self, data: None) -> str: ...


class ConfigInterface(GObject.GInterface):
    """
    Interface GimpConfigInterface

    Signals from GObject:
      notify (GParam)
    """
    @staticmethod
    def build_data_path(name: str) -> str: ...
    @staticmethod
    def build_plug_in_path(name: str) -> str: ...
    @staticmethod
    def build_system_path(name: str) -> str: ...
    @staticmethod
    def build_writable_path(name: str) -> str: ...
    @staticmethod
    def deserialize_return(scanner: GLib.Scanner, expected_token: GLib.TokenType, nest_level: int) -> bool: ...
    @staticmethod
    def diff(a: GObject.Object, b: GObject.Object, flags: GObject.ParamFlags) -> list[GObject.ParamSpec]: ...
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def param_spec_duplicate(pspec: GObject.ParamSpec) -> GObject.ParamSpec: ...
    @staticmethod
    def reset_properties(object: GObject.Object) -> None: ...
    @staticmethod
    def reset_property(object: GObject.Object, property_name: str) -> None: ...
    @staticmethod
    def serialize_value(value: typing.Any, str: GLib.String, escaped: bool) -> bool: ...
    @staticmethod
    def string_append_escaped(string: GLib.String, val: str) -> None: ...
    @staticmethod
    def sync(src: GObject.Object, dest: GObject.Object, flags: GObject.ParamFlags) -> bool: ...
    @staticmethod
    def type_register(parent_type: typing.Type[typing.Any], type_name: str, pspecs: typing.Sequence[GObject.ParamSpec]) -> typing.Type[typing.Any]: ...


class ConfigPath:
    """
    :Constructors:

    ::

        ConfigPath(**properties)
    """
    @staticmethod
    def expand(path: str, recode: bool) -> str: ...
    @staticmethod
    def expand_to_files(path: str) -> list[Gio.File]: ...
    @staticmethod
    def unexpand(path: str, recode: bool) -> str: ...


class ConfigWriter(GObject.GBoxed):
    """
    :Constructors:

    ::

        new_from_fd(fd:int) -> Gimp.ConfigWriter or None
        new_from_file(file:Gio.File, atomic:bool, header:str) -> Gimp.ConfigWriter or None
        new_from_stream(output:Gio.OutputStream, header:str) -> Gimp.ConfigWriter or None
        new_from_string(string:GLib.String) -> Gimp.ConfigWriter or None
    """
    def close(self) -> None: ...
    def comment(self, comment: str) -> None: ...
    def comment_mode(self, enable: bool) -> None: ...
    def data(self, data: typing.Sequence[int]) -> None: ...
    def finish(self, footer: str) -> bool: ...
    def identifier(self, identifier: str) -> None: ...
    def linefeed(self) -> None: ...
    @classmethod
    def new_from_fd(cls, fd: int) -> typing.Optional[ConfigWriter]: ...
    @classmethod
    def new_from_file(cls, file: Gio.File, atomic: bool, header: str) -> typing.Optional[ConfigWriter]: ...
    @classmethod
    def new_from_stream(cls, output: Gio.OutputStream, header: str) -> typing.Optional[ConfigWriter]: ...
    @classmethod
    def new_from_string(cls, string: GLib.String) -> typing.Optional[ConfigWriter]: ...
    def open(self, name: str) -> None: ...
    def print_(self, string: str, len: int) -> None: ...
    def ref(self) -> ConfigWriter: ...
    def revert(self) -> None: ...
    def string(self, string: str) -> None: ...
    def unref(self) -> None: ...


class Display(GObject.Object):
    """
    :Constructors:

    ::

        Display(**properties)
        new(image:Gimp.Image) -> Gimp.Display

    Object GimpDisplay

    Properties from GimpDisplay:
      id -> gint: The display id
        The display id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def delete(self) -> bool: ...
    @staticmethod
    def get_by_id(display_id: int) -> typing.Optional[Display]: ...
    def get_id(self) -> int: ...
    def get_window_handle(self) -> GLib.Bytes: ...
    @staticmethod
    def id_is_valid(display_id: int) -> bool: ...
    def is_valid(self) -> bool: ...
    @staticmethod
    def name() -> str: ...
    @classmethod
    def new(cls, image: Image) -> Display: ...
    def present(self) -> bool: ...


class DisplayClass(GObject.GPointer):
    """
    :Constructors:

    ::

        DisplayClass()
    """
    parent_class: GObject.ObjectClass = ...

class DoubleArray(GObject.GBoxed):
    @staticmethod
    def get_values(array: Array) -> list[float]: ...
    @staticmethod
    def set_values(array: Array, values: typing.Sequence[float], static_data: bool) -> None: ...


class Drawable(Item):
    """
    :Constructors:

    ::

        Drawable(**properties)

    Object GimpDrawable

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    parent_instance: Item = ...
    def __init__(self, id: int = ...) -> None: ...
    def append_filter(self, filter: DrawableFilter) -> None: ...
    def brightness_contrast(self, brightness: float, contrast: float) -> bool: ...
    def color_balance(self, transfer_mode: TransferMode, preserve_lum: bool, cyan_red: float, magenta_green: float, yellow_blue: float) -> bool: ...
    def colorize_hsl(self, hue: float, saturation: float, lightness: float) -> bool: ...
    def curves_explicit(self, channel: HistogramChannel, values: typing.Sequence[float]) -> bool: ...
    def curves_spline(self, channel: HistogramChannel, points: typing.Sequence[float]) -> bool: ...
    def desaturate(self, desaturate_mode: DesaturateMode) -> bool: ...
    def edit_bucket_fill(self, fill_type: FillType, x: float, y: float) -> bool: ...
    def edit_clear(self) -> bool: ...
    def edit_fill(self, fill_type: FillType) -> bool: ...
    def edit_gradient_fill(self, gradient_type: GradientType, offset: float, supersample: bool, supersample_max_depth: int, supersample_threshold: float, dither: bool, x1: float, y1: float, x2: float, y2: float) -> bool: ...
    def edit_stroke_item(self, item: Item) -> bool: ...
    def edit_stroke_selection(self) -> bool: ...
    def equalize(self, mask_only: bool) -> bool: ...
    def extract_component(self, component: int, invert: bool, linear: bool) -> bool: ...
    def fill(self, fill_type: FillType) -> bool: ...
    def foreground_extract(self, mode: ForegroundExtractMode, mask: Drawable) -> bool: ...
    def free_shadow(self) -> bool: ...
    def get_bpp(self) -> int: ...
    def get_buffer(self) -> Gegl.Buffer: ...
    @staticmethod
    def get_by_id(drawable_id: int) -> typing.Optional[Drawable]: ...
    def get_filters(self) -> list[DrawableFilter]: ...
    def get_format(self) -> Babl.Object: ...
    def get_height(self) -> int: ...
    def get_offsets(self) -> typing.Tuple[bool, int, int]: ...
    def get_pixel(self, x_coord: int, y_coord: int) -> Gegl.Color: ...
    def get_shadow_buffer(self) -> Gegl.Buffer: ...
    def get_sub_thumbnail(self, src_x: int, src_y: int, src_width: int, src_height: int, dest_width: int, dest_height: int, alpha: PixbufTransparency) -> GdkPixbuf.Pixbuf: ...
    def get_sub_thumbnail_data(self, src_x: int, src_y: int, src_width: int, src_height: int, dest_width: int, dest_height: int) -> typing.Tuple[GLib.Bytes, int, int, int]: ...
    def get_thumbnail(self, width: int, height: int, alpha: PixbufTransparency) -> GdkPixbuf.Pixbuf: ...
    def get_thumbnail_data(self, width: int, height: int) -> typing.Tuple[typing.Optional[GLib.Bytes], int, int, int]: ...
    def get_thumbnail_format(self) -> Babl.Object: ...
    def get_width(self) -> int: ...
    def has_alpha(self) -> bool: ...
    def histogram(self, channel: HistogramChannel, start_range: float, end_range: float) -> typing.Tuple[bool, float, float, float, float, float, float]: ...
    def hue_saturation(self, hue_range: HueRange, hue_offset: float, lightness: float, saturation: float, overlap: float) -> bool: ...
    def invert(self, linear: bool) -> bool: ...
    def is_gray(self) -> bool: ...
    def is_indexed(self) -> bool: ...
    def is_rgb(self) -> bool: ...
    def levels(self, channel: HistogramChannel, low_input: float, high_input: float, clamp_input: bool, gamma: float, low_output: float, high_output: float, clamp_output: bool) -> bool: ...
    def levels_stretch(self) -> bool: ...
    def mask_bounds(self) -> typing.Tuple[bool, int, int, int, int]: ...
    def mask_intersect(self) -> typing.Tuple[bool, int, int, int, int]: ...
    def merge_filter(self, filter: DrawableFilter) -> None: ...
    def merge_filters(self) -> bool: ...
    def merge_shadow(self, undo: bool) -> bool: ...
    def offset(self, wrap_around: bool, fill_type: OffsetType, color: Gegl.Color, offset_x: int, offset_y: int) -> bool: ...
    def posterize(self, levels: int) -> bool: ...
    def set_pixel(self, x_coord: int, y_coord: int, color: Gegl.Color) -> bool: ...
    def shadows_highlights(self, shadows: float, highlights: float, whitepoint: float, radius: float, compress: float, shadows_ccorrect: float, highlights_ccorrect: float) -> bool: ...
    def threshold(self, channel: HistogramChannel, low_threshold: float, high_threshold: float) -> bool: ...
    def type(self) -> ImageType: ...
    def type_with_alpha(self) -> ImageType: ...
    def update(self, x: int, y: int, width: int, height: int) -> bool: ...


class DrawableClass(GObject.GPointer):
    """
    :Constructors:

    ::

        DrawableClass()
    """
    parent_class: ItemClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class DrawableFilter(GObject.Object):
    """
    :Constructors:

    ::

        DrawableFilter(**properties)
        new(drawable:Gimp.Drawable, operation_name:str, name:str=None) -> Gimp.DrawableFilter

    Object GimpDrawableFilter

    Properties from GimpDrawableFilter:
      id -> gint: The drawable_filter id
        The drawable_filter id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def delete(self) -> bool: ...
    def get_blend_mode(self) -> LayerMode: ...
    @staticmethod
    def get_by_id(filter_id: int) -> typing.Optional[DrawableFilter]: ...
    def get_config(self) -> DrawableFilterConfig: ...
    def get_id(self) -> int: ...
    def get_name(self) -> str: ...
    def get_opacity(self) -> float: ...
    def get_operation_name(self) -> str: ...
    def get_visible(self) -> bool: ...
    @staticmethod
    def id_is_valid(filter_id: int) -> bool: ...
    def is_valid(self) -> bool: ...
    @classmethod
    def new(cls, drawable: Drawable, operation_name: str, name: typing.Optional[str] = None) -> DrawableFilter: ...
    def set_aux_input(self, input_pad_name: str, input: Drawable) -> None: ...
    def set_blend_mode(self, mode: LayerMode) -> None: ...
    def set_opacity(self, opacity: float) -> None: ...
    def set_visible(self, visible: bool) -> bool: ...
    def update(self) -> None: ...


class DrawableFilterClass(GObject.GPointer):
    """
    :Constructors:

    ::

        DrawableFilterClass()
    """
    parent_class: GObject.ObjectClass = ...

class DrawableFilterConfig(GObject.Object):
    """
    :Constructors:

    ::

        DrawableFilterConfig(**properties)

    Object GimpDrawableFilterConfig

    Signals from GObject:
      notify (GParam)
    """
    parent_instance: GObject.Object = ...

class DrawableFilterConfigClass(GObject.GPointer):
    """
    :Constructors:

    ::

        DrawableFilterConfigClass()
    """
    parent_class: GObject.ObjectClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class EnumDesc(GObject.GPointer):
    """
    :Constructors:

    ::

        EnumDesc()
    """
    value: int = ...
    value_desc: str = ...
    value_help: str = ...

class ExportOptions(GObject.Object):
    """
    :Constructors:

    ::

        ExportOptions(**properties)

    Object GimpExportOptions

    Properties from GimpExportOptions:
      capabilities -> GimpExportCapabilities: Supported image capabilities

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        capabilities: ExportCapabilities
    props: Props = ...
    def __init__(self, capabilities: ExportCapabilities = ...) -> None: ...
    def get_image(self) -> typing.Tuple[ExportReturn, Image]: ...


class ExportOptionsClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ExportOptionsClass()
    """
    parent_class: GObject.ObjectClass = ...

class ExportProcedure(FileProcedure):
    """
    :Constructors:

    ::

        ExportProcedure(**properties)
        new(plug_in:Gimp.PlugIn, name:str, proc_type:Gimp.PDBProcType, export_metadata:bool, run_func:Gimp.RunExportFunc, run_data=None) -> Gimp.Procedure

    Object GimpExportProcedure

    Properties from GimpExportProcedure:
      capabilities -> GimpExportCapabilities: Supported image capabilities
      supports-exif -> gboolean: Supports EXIF metadata storage
      supports-iptc -> gboolean: Supports IPTC metadata storage
      supports-xmp -> gboolean: Supports XMP metadata storage
      supports-profile -> gboolean: Supports color profile storage
      supports-thumbnail -> gboolean: Supports thumbnail storage
      supports-comment -> gboolean: Supports comment storage

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        capabilities: ExportCapabilities
        supports_comment: bool
        supports_exif: bool
        supports_iptc: bool
        supports_profile: bool
        supports_thumbnail: bool
        supports_xmp: bool
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    def __init__(self, capabilities: ExportCapabilities = ...,
                 supports_comment: bool = ...,
                 supports_exif: bool = ...,
                 supports_iptc: bool = ...,
                 supports_profile: bool = ...,
                 supports_thumbnail: bool = ...,
                 supports_xmp: bool = ...,
                 name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    def get_support_comment(self) -> bool: ...
    def get_support_exif(self) -> bool: ...
    def get_support_iptc(self) -> bool: ...
    def get_support_profile(self) -> bool: ...
    def get_support_thumbnail(self) -> bool: ...
    def get_support_xmp(self) -> bool: ...
    @classmethod
    def new(cls, plug_in: PlugIn, name: str, proc_type: PDBProcType, export_metadata: bool, run_func: typing.Callable[..., ValueArray], *run_data: typing.Any) -> ExportProcedure: ...
    def set_capabilities(self, capabilities: ExportCapabilities, get_capabilities_func: typing.Optional[typing.Callable[..., ExportCapabilities]] = None, *get_capabilities_data: typing.Any) -> None: ...
    def set_support_comment(self, supports: bool) -> None: ...
    def set_support_exif(self, supports: bool) -> None: ...
    def set_support_iptc(self, supports: bool) -> None: ...
    def set_support_profile(self, supports: bool) -> None: ...
    def set_support_thumbnail(self, supports: bool) -> None: ...
    def set_support_xmp(self, supports: bool) -> None: ...


class ExportProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ExportProcedureClass()
    """
    parent_class: FileProcedureClass = ...

class FileProcedure(Procedure):
    """
    :Constructors:

    ::

        FileProcedure(**properties)

    Object GimpFileProcedure

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    parent_instance: Procedure = ...
    def __init__(self, name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    def get_extensions(self) -> str: ...
    def get_format_name(self) -> str: ...
    def get_handles_remote(self) -> bool: ...
    def get_magics(self) -> str: ...
    def get_mime_types(self) -> str: ...
    def get_prefixes(self) -> str: ...
    def get_priority(self) -> int: ...
    def set_extensions(self, extensions: str) -> None: ...
    def set_format_name(self, format_name: str) -> None: ...
    def set_handles_remote(self, handles_remote: bool) -> None: ...
    def set_magics(self, magics: str) -> None: ...
    def set_mime_types(self, mime_types: str) -> None: ...
    def set_prefixes(self, prefixes: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...


class FileProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        FileProcedureClass()
    """
    parent_class: ProcedureClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class FlagsDesc(GObject.GPointer):
    """
    :Constructors:

    ::

        FlagsDesc()
    """
    value: int = ...
    value_desc: str = ...
    value_help: str = ...

class Font(Resource, ConfigInterface):
    """
    :Constructors:

    ::

        Font(**properties)

    Object GimpFont

    Properties from GimpResource:
      id -> gint: The id
        The id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    @staticmethod
    def get_by_name(name: str) -> typing.Optional[Font]: ...
    def get_pango_font_description(self) -> Pango.FontDescription: ...


class FontClass(GObject.GPointer):
    """
    :Constructors:

    ::

        FontClass()
    """
    parent_class: ResourceClass = ...

class Gradient(Resource, ConfigInterface):
    """
    :Constructors:

    ::

        Gradient(**properties)
        new(name:str) -> Gimp.Gradient

    Object GimpGradient

    Properties from GimpResource:
      id -> gint: The id
        The id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    @staticmethod
    def get_by_name(name: str) -> typing.Optional[Gradient]: ...
    def get_custom_samples(self, positions: typing.Sequence[float], reverse: bool) -> list[Gegl.Color]: ...
    def get_number_of_segments(self) -> int: ...
    def get_uniform_samples(self, num_samples: int, reverse: bool) -> list[Gegl.Color]: ...
    @classmethod
    def new(cls, name: str) -> Gradient: ...
    def segment_get_blending_function(self, segment: int) -> typing.Tuple[bool, GradientSegmentType]: ...
    def segment_get_coloring_type(self, segment: int) -> typing.Tuple[bool, GradientSegmentColor]: ...
    def segment_get_left_color(self, segment: int) -> Gegl.Color: ...
    def segment_get_left_pos(self, segment: int) -> typing.Tuple[bool, float]: ...
    def segment_get_middle_pos(self, segment: int) -> typing.Tuple[bool, float]: ...
    def segment_get_right_color(self, segment: int) -> Gegl.Color: ...
    def segment_get_right_pos(self, segment: int) -> typing.Tuple[bool, float]: ...
    def segment_range_blend_colors(self, start_segment: int, end_segment: int) -> bool: ...
    def segment_range_blend_opacity(self, start_segment: int, end_segment: int) -> bool: ...
    def segment_range_delete(self, start_segment: int, end_segment: int) -> bool: ...
    def segment_range_flip(self, start_segment: int, end_segment: int) -> bool: ...
    def segment_range_move(self, start_segment: int, end_segment: int, delta: float, control_compress: bool) -> float: ...
    def segment_range_redistribute_handles(self, start_segment: int, end_segment: int) -> bool: ...
    def segment_range_replicate(self, start_segment: int, end_segment: int, replicate_times: int) -> bool: ...
    def segment_range_set_blending_function(self, start_segment: int, end_segment: int, blending_function: GradientSegmentType) -> bool: ...
    def segment_range_set_coloring_type(self, start_segment: int, end_segment: int, coloring_type: GradientSegmentColor) -> bool: ...
    def segment_range_split_midpoint(self, start_segment: int, end_segment: int) -> bool: ...
    def segment_range_split_uniform(self, start_segment: int, end_segment: int, split_parts: int) -> bool: ...
    def segment_set_left_color(self, segment: int, color: Gegl.Color) -> bool: ...
    def segment_set_left_pos(self, segment: int, pos: float) -> typing.Tuple[bool, float]: ...
    def segment_set_middle_pos(self, segment: int, pos: float) -> typing.Tuple[bool, float]: ...
    def segment_set_right_color(self, segment: int, color: Gegl.Color) -> bool: ...
    def segment_set_right_pos(self, segment: int, pos: float) -> typing.Tuple[bool, float]: ...


class GradientClass(GObject.GPointer):
    """
    :Constructors:

    ::

        GradientClass()
    """
    parent_class: ResourceClass = ...

class GroupLayer(Layer):
    """
    :Constructors:

    ::

        GroupLayer(**properties)
        new(image:Gimp.Image, name:str=None) -> Gimp.GroupLayer

    Object GimpGroupLayer

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    @staticmethod
    def get_by_id(layer_id: int) -> typing.Optional[GroupLayer]: ...
    def merge(self) -> Layer: ...
    @classmethod
    def new(cls, image: Image, name: typing.Optional[str] = None) -> GroupLayer: ...


class GroupLayerClass(GObject.GPointer):
    """
    :Constructors:

    ::

        GroupLayerClass()
    """
    parent_class: LayerClass = ...

class Image(GObject.Object):
    """
    :Constructors:

    ::

        Image(**properties)
        new(width:int, height:int, type:Gimp.ImageBaseType) -> Gimp.Image
        new_with_precision(width:int, height:int, type:Gimp.ImageBaseType, precision:Gimp.Precision) -> Gimp.Image

    Object GimpImage

    Properties from GimpImage:
      id -> gint: The image id
        The image id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def add_hguide(self, yposition: int) -> int: ...
    def add_sample_point(self, position_x: int, position_y: int) -> int: ...
    def add_vguide(self, xposition: int) -> int: ...
    def attach_parasite(self, parasite: Parasite) -> bool: ...
    def autocrop(self, drawable: typing.Optional[Drawable] = None) -> bool: ...
    def autocrop_selected_layers(self, drawable: typing.Optional[Drawable] = None) -> bool: ...
    def clean_all(self) -> bool: ...
    def convert_color_profile(self, profile: ColorProfile, intent: ColorRenderingIntent, bpc: bool) -> bool: ...
    def convert_color_profile_from_file(self, file: Gio.File, intent: ColorRenderingIntent, bpc: bool) -> bool: ...
    def convert_grayscale(self) -> bool: ...
    def convert_indexed(self, dither_type: ConvertDitherType, palette_type: ConvertPaletteType, num_cols: int, alpha_dither: bool, remove_unused: bool, palette: str) -> bool: ...
    def convert_precision(self, precision: Precision) -> bool: ...
    def convert_rgb(self) -> bool: ...
    @staticmethod
    def convert_set_dither_matrix(width: int, height: int, matrix: GLib.Bytes) -> bool: ...
    def crop(self, new_width: int, new_height: int, offx: int, offy: int) -> bool: ...
    def delete(self) -> bool: ...
    def delete_guide(self, guide: int) -> bool: ...
    def delete_sample_point(self, sample_point: int) -> bool: ...
    def detach_parasite(self, name: str) -> bool: ...
    def duplicate(self) -> Image: ...
    def export_path_to_file(self, file: Gio.File, path: typing.Optional[Path] = None) -> bool: ...
    def export_path_to_string(self, path: typing.Optional[Path] = None) -> str: ...
    def find_next_guide(self, guide: int) -> int: ...
    def find_next_sample_point(self, sample_point: int) -> int: ...
    def flatten(self) -> Layer: ...
    def flip(self, flip_type: OrientationType) -> bool: ...
    def floating_sel_attached_to(self) -> Drawable: ...
    def freeze_channels(self) -> bool: ...
    def freeze_layers(self) -> bool: ...
    def freeze_paths(self) -> bool: ...
    def get_base_type(self) -> ImageBaseType: ...
    @staticmethod
    def get_by_id(image_id: int) -> typing.Optional[Image]: ...
    def get_channel_by_name(self, name: str) -> Channel: ...
    def get_channel_by_tattoo(self, tattoo: int) -> Channel: ...
    def get_channels(self) -> list[Channel]: ...
    def get_color_profile(self) -> ColorProfile: ...
    def get_component_active(self, component: ChannelType) -> bool: ...
    def get_component_visible(self, component: ChannelType) -> bool: ...
    def get_default_new_layer_mode(self) -> LayerMode: ...
    def get_effective_color_profile(self) -> ColorProfile: ...
    def get_exported_file(self) -> Gio.File: ...
    def get_file(self) -> Gio.File: ...
    def get_floating_sel(self) -> Layer: ...
    def get_guide_orientation(self, guide: int) -> OrientationType: ...
    def get_guide_position(self, guide: int) -> int: ...
    def get_height(self) -> int: ...
    def get_id(self) -> int: ...
    def get_imported_file(self) -> Gio.File: ...
    def get_item_position(self, item: Item) -> int: ...
    def get_layer_by_name(self, name: str) -> Layer: ...
    def get_layer_by_tattoo(self, tattoo: int) -> Layer: ...
    def get_layers(self) -> list[Layer]: ...
    def get_metadata(self) -> typing.Optional[Metadata]: ...
    def get_name(self) -> str: ...
    def get_palette(self) -> Palette: ...
    def get_parasite(self, name: str) -> Parasite: ...
    def get_parasite_list(self) -> list[str]: ...
    def get_path_by_name(self, name: str) -> Path: ...
    def get_path_by_tattoo(self, tattoo: int) -> Path: ...
    def get_paths(self) -> list[Path]: ...
    def get_precision(self) -> Precision: ...
    def get_resolution(self) -> typing.Tuple[bool, float, float]: ...
    def get_sample_point_position(self, sample_point: int) -> typing.Tuple[int, int]: ...
    def get_selected_channels(self) -> list[Channel]: ...
    def get_selected_drawables(self) -> list[Drawable]: ...
    def get_selected_layers(self) -> list[Layer]: ...
    def get_selected_paths(self) -> list[Path]: ...
    def get_selection(self) -> Selection: ...
    def get_simulation_bpc(self) -> bool: ...
    def get_simulation_intent(self) -> ColorRenderingIntent: ...
    def get_simulation_profile(self) -> ColorProfile: ...
    def get_tattoo_state(self) -> int: ...
    def get_thumbnail(self, width: int, height: int, alpha: PixbufTransparency) -> GdkPixbuf.Pixbuf: ...
    def get_thumbnail_data(self) -> typing.Tuple[GLib.Bytes, int, int, int]: ...
    def get_unit(self) -> Unit: ...
    def get_width(self) -> int: ...
    def get_xcf_file(self) -> Gio.File: ...
    def grid_get_background_color(self) -> Gegl.Color: ...
    def grid_get_foreground_color(self) -> Gegl.Color: ...
    def grid_get_offset(self) -> typing.Tuple[bool, float, float]: ...
    def grid_get_spacing(self) -> typing.Tuple[bool, float, float]: ...
    def grid_get_style(self) -> GridStyle: ...
    def grid_set_background_color(self, bgcolor: Gegl.Color) -> bool: ...
    def grid_set_foreground_color(self, fgcolor: Gegl.Color) -> bool: ...
    def grid_set_offset(self, xoffset: float, yoffset: float) -> bool: ...
    def grid_set_spacing(self, xspacing: float, yspacing: float) -> bool: ...
    def grid_set_style(self, style: GridStyle) -> bool: ...
    @staticmethod
    def id_is_valid(image_id: int) -> bool: ...
    def import_paths_from_file(self, file: Gio.File, merge: bool, scale: bool) -> typing.Tuple[bool, list[Path]]: ...
    def import_paths_from_string(self, string: str, length: int, merge: bool, scale: bool) -> typing.Tuple[bool, list[Path]]: ...
    def insert_channel(self, channel: Channel, parent: typing.Optional[Channel], position: int) -> bool: ...
    def insert_layer(self, layer: Layer, parent: typing.Optional[Layer], position: int) -> bool: ...
    def insert_path(self, path: Path, parent: typing.Optional[Path], position: int) -> bool: ...
    def is_dirty(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def lower_item(self, item: Item) -> bool: ...
    def lower_item_to_bottom(self, item: Item) -> bool: ...
    def merge_down(self, merge_layer: Layer, merge_type: MergeType) -> Layer: ...
    def merge_visible_layers(self, merge_type: MergeType) -> Layer: ...
    @staticmethod
    def metadata_load_thumbnail(file: Gio.File) -> typing.Optional[Image]: ...
    def metadata_save_filter(self, mime_type: str, metadata: Metadata, flags: MetadataSaveFlags, file: Gio.File) -> Metadata: ...
    def metadata_save_prepare(self, mime_type: str, suggested_flags: MetadataSaveFlags) -> Metadata: ...
    @classmethod
    def new(cls, width: int, height: int, type: ImageBaseType) -> Image: ...
    @classmethod
    def new_with_precision(cls, width: int, height: int, type: ImageBaseType, precision: Precision) -> Image: ...
    def pick_color(self, drawables: typing.Sequence[Drawable], x: float, y: float, sample_merged: bool, sample_average: bool, average_radius: float) -> typing.Tuple[bool, Gegl.Color]: ...
    def pick_correlate_layer(self, x: int, y: int) -> Layer: ...
    def policy_color_profile(self, interactive: bool) -> bool: ...
    def policy_rotate(self, interactive: bool) -> bool: ...
    def raise_item(self, item: Item) -> bool: ...
    def raise_item_to_top(self, item: Item) -> bool: ...
    def remove_channel(self, channel: Channel) -> bool: ...
    def remove_layer(self, layer: Layer) -> bool: ...
    def remove_path(self, path: Path) -> bool: ...
    def reorder_item(self, item: Item, parent: typing.Optional[Item], position: int) -> bool: ...
    def resize(self, new_width: int, new_height: int, offx: int, offy: int) -> bool: ...
    def resize_to_layers(self) -> bool: ...
    def rotate(self, rotate_type: RotationType) -> bool: ...
    def scale(self, new_width: int, new_height: int) -> bool: ...
    def select_color(self, operation: ChannelOps, drawable: Drawable, color: Gegl.Color) -> bool: ...
    def select_contiguous_color(self, operation: ChannelOps, drawable: Drawable, x: float, y: float) -> bool: ...
    def select_ellipse(self, operation: ChannelOps, x: float, y: float, width: float, height: float) -> bool: ...
    def select_item(self, operation: ChannelOps, item: Item) -> bool: ...
    def select_polygon(self, operation: ChannelOps, segs: typing.Sequence[float]) -> bool: ...
    def select_rectangle(self, operation: ChannelOps, x: float, y: float, width: float, height: float) -> bool: ...
    def select_round_rectangle(self, operation: ChannelOps, x: float, y: float, width: float, height: float, corner_radius_x: float, corner_radius_y: float) -> bool: ...
    def set_color_profile(self, profile: typing.Optional[ColorProfile] = None) -> bool: ...
    def set_color_profile_from_file(self, file: Gio.File) -> bool: ...
    def set_component_active(self, component: ChannelType, active: bool) -> bool: ...
    def set_component_visible(self, component: ChannelType, visible: bool) -> bool: ...
    def set_file(self, file: Gio.File) -> bool: ...
    def set_metadata(self, metadata: Metadata) -> bool: ...
    def set_palette(self, new_palette: Palette) -> Palette: ...
    def set_resolution(self, xresolution: float, yresolution: float) -> bool: ...
    def set_selected_channels(self, channels: typing.Sequence[Channel]) -> bool: ...
    def set_selected_layers(self, layers: typing.Sequence[Layer]) -> bool: ...
    def set_selected_paths(self, paths: typing.Sequence[Path]) -> bool: ...
    def set_simulation_bpc(self, bpc: bool) -> bool: ...
    def set_simulation_intent(self, intent: ColorRenderingIntent) -> bool: ...
    def set_simulation_profile(self, profile: typing.Optional[ColorProfile] = None) -> bool: ...
    def set_simulation_profile_from_file(self, file: Gio.File) -> bool: ...
    def set_tattoo_state(self, tattoo_state: int) -> bool: ...
    def set_unit(self, unit: Unit) -> bool: ...
    def take_selected_channels(self, channels: list[Channel]) -> bool: ...
    def take_selected_layers(self, layers: list[Layer]) -> bool: ...
    def take_selected_paths(self, paths: list[Path]) -> bool: ...
    def thaw_channels(self) -> bool: ...
    def thaw_layers(self) -> bool: ...
    def thaw_paths(self) -> bool: ...
    def undo_disable(self) -> bool: ...
    def undo_enable(self) -> bool: ...
    def undo_freeze(self) -> bool: ...
    def undo_group_end(self) -> bool: ...
    def undo_group_start(self) -> bool: ...
    def undo_is_enabled(self) -> bool: ...
    def undo_thaw(self) -> bool: ...
    def unset_active_channel(self) -> bool: ...


class ImageClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ImageClass()
    """
    parent_class: GObject.ObjectClass = ...

class ImageProcedure(Procedure):
    """
    :Constructors:

    ::

        ImageProcedure(**properties)
        new(plug_in:Gimp.PlugIn, name:str, proc_type:Gimp.PDBProcType, run_func:Gimp.RunImageFunc) -> Gimp.Procedure

    Object GimpImageProcedure

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    def __init__(self, name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    @classmethod
    def new(cls, plug_in: PlugIn, name: str, proc_type: PDBProcType, run_func: typing.Callable[..., ValueArray], *run_data: typing.Any) -> ImageProcedure: ...


class ImageProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ImageProcedureClass()
    """
    parent_class: ProcedureClass = ...

class Int32Array(GObject.GBoxed):
    @staticmethod
    def get_values(array: Array) -> list[int]: ...
    @staticmethod
    def set_values(array: Array, values: typing.Sequence[int], static_data: bool) -> None: ...


class Item(GObject.Object):
    """
    :Constructors:

    ::

        Item(**properties)

    Object GimpItem

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    parent_instance: GObject.Object = ...
    def __init__(self, id: int = ...) -> None: ...
    def attach_parasite(self, parasite: Parasite) -> bool: ...
    def delete(self) -> bool: ...
    def detach_parasite(self, name: str) -> bool: ...
    @staticmethod
    def get_by_id(item_id: int) -> typing.Optional[Item]: ...
    def get_children(self) -> list[Item]: ...
    def get_color_tag(self) -> ColorTag: ...
    def get_expanded(self) -> bool: ...
    def get_id(self) -> int: ...
    def get_image(self) -> Image: ...
    def get_lock_content(self) -> bool: ...
    def get_lock_position(self) -> bool: ...
    def get_lock_visibility(self) -> bool: ...
    def get_name(self) -> str: ...
    def get_parasite(self, name: str) -> Parasite: ...
    def get_parasite_list(self) -> list[str]: ...
    def get_parent(self) -> Item: ...
    def get_tattoo(self) -> int: ...
    def get_visible(self) -> bool: ...
    @staticmethod
    def id_is_channel(item_id: int) -> bool: ...
    @staticmethod
    def id_is_drawable(item_id: int) -> bool: ...
    @staticmethod
    def id_is_group_layer(item_id: int) -> bool: ...
    @staticmethod
    def id_is_layer(item_id: int) -> bool: ...
    @staticmethod
    def id_is_layer_mask(item_id: int) -> bool: ...
    @staticmethod
    def id_is_path(item_id: int) -> bool: ...
    @staticmethod
    def id_is_selection(item_id: int) -> bool: ...
    @staticmethod
    def id_is_text_layer(item_id: int) -> bool: ...
    @staticmethod
    def id_is_valid(item_id: int) -> bool: ...
    def is_channel(self) -> bool: ...
    def is_drawable(self) -> bool: ...
    def is_group(self) -> bool: ...
    def is_group_layer(self) -> bool: ...
    def is_layer(self) -> bool: ...
    def is_layer_mask(self) -> bool: ...
    def is_path(self) -> bool: ...
    def is_selection(self) -> bool: ...
    def is_text_layer(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def set_color_tag(self, color_tag: ColorTag) -> bool: ...
    def set_expanded(self, expanded: bool) -> bool: ...
    def set_lock_content(self, lock_content: bool) -> bool: ...
    def set_lock_position(self, lock_position: bool) -> bool: ...
    def set_lock_visibility(self, lock_visibility: bool) -> bool: ...
    def set_name(self, name: str) -> bool: ...
    def set_tattoo(self, tattoo: int) -> bool: ...
    def set_visible(self, visible: bool) -> bool: ...
    def transform_2d(self, source_x: float, source_y: float, scale_x: float, scale_y: float, angle: float, dest_x: float, dest_y: float) -> Item: ...
    def transform_flip(self, x0: float, y0: float, x1: float, y1: float) -> Item: ...
    def transform_flip_simple(self, flip_type: OrientationType, auto_center: bool, axis: float) -> Item: ...
    def transform_matrix(self, coeff_0_0: float, coeff_0_1: float, coeff_0_2: float, coeff_1_0: float, coeff_1_1: float, coeff_1_2: float, coeff_2_0: float, coeff_2_1: float, coeff_2_2: float) -> Item: ...
    def transform_perspective(self, x0: float, y0: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> Item: ...
    def transform_rotate(self, angle: float, auto_center: bool, center_x: float, center_y: float) -> Item: ...
    def transform_rotate_simple(self, rotate_type: RotationType, auto_center: bool, center_x: float, center_y: float) -> Item: ...
    def transform_scale(self, x0: float, y0: float, x1: float, y1: float) -> Item: ...
    def transform_shear(self, shear_type: OrientationType, magnitude: float) -> Item: ...
    def transform_translate(self, off_x: float, off_y: float) -> Item: ...


class ItemClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ItemClass()
    """
    parent_class: GObject.ObjectClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class Layer(Drawable):
    """
    :Constructors:

    ::

        Layer(**properties)
        new(image:Gimp.Image, name:str=None, width:int, height:int, type:Gimp.ImageType, opacity:float, mode:Gimp.LayerMode) -> Gimp.Layer
        new_from_drawable(drawable:Gimp.Drawable, dest_image:Gimp.Image) -> Gimp.Layer
        new_from_pixbuf(image:Gimp.Image, name:str, pixbuf:GdkPixbuf.Pixbuf, opacity:float, mode:Gimp.LayerMode, progress_start:float, progress_end:float) -> Gimp.Layer
        new_from_surface(image:Gimp.Image, name:str, surface:cairo.Surface, progress_start:float, progress_end:float) -> Gimp.Layer
        new_from_visible(image:Gimp.Image, dest_image:Gimp.Image, name:str=None) -> Gimp.Layer

    Object GimpLayer

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    parent_instance: Drawable = ...
    def __init__(self, id: int = ...) -> None: ...
    def add_alpha(self) -> bool: ...
    def add_mask(self, mask: LayerMask) -> bool: ...
    def copy(self) -> Layer: ...
    def create_mask(self, mask_type: AddMaskType) -> LayerMask: ...
    def flatten(self) -> bool: ...
    @staticmethod
    def from_mask(mask: LayerMask) -> Layer: ...
    def get_apply_mask(self) -> bool: ...
    def get_blend_space(self) -> LayerColorSpace: ...
    @staticmethod
    def get_by_id(layer_id: int) -> typing.Optional[Layer]: ...
    def get_composite_mode(self) -> LayerCompositeMode: ...
    def get_composite_space(self) -> LayerColorSpace: ...
    def get_edit_mask(self) -> bool: ...
    def get_lock_alpha(self) -> bool: ...
    def get_mask(self) -> LayerMask: ...
    def get_mode(self) -> LayerMode: ...
    def get_opacity(self) -> float: ...
    def get_show_mask(self) -> bool: ...
    def is_floating_sel(self) -> bool: ...
    @classmethod
    def new(cls, image: Image, name: typing.Optional[str], width: int, height: int, type: ImageType, opacity: float, mode: LayerMode) -> Layer: ...
    @classmethod
    def new_from_drawable(cls, drawable: Drawable, dest_image: Image) -> Layer: ...
    @classmethod
    def new_from_pixbuf(cls, image: Image, name: str, pixbuf: GdkPixbuf.Pixbuf, opacity: float, mode: LayerMode, progress_start: float, progress_end: float) -> Layer: ...
    @classmethod
    def new_from_surface(cls, image: Image, name: str, surface: cairo.Surface, progress_start: float, progress_end: float) -> Layer: ...
    @classmethod
    def new_from_visible(cls, image: Image, dest_image: Image, name: typing.Optional[str] = None) -> Layer: ...
    def remove_mask(self, mode: MaskApplyMode) -> bool: ...
    def resize(self, new_width: int, new_height: int, offx: int, offy: int) -> bool: ...
    def resize_to_image_size(self) -> bool: ...
    def scale(self, new_width: int, new_height: int, local_origin: bool) -> bool: ...
    def set_apply_mask(self, apply_mask: bool) -> bool: ...
    def set_blend_space(self, blend_space: LayerColorSpace) -> bool: ...
    def set_composite_mode(self, composite_mode: LayerCompositeMode) -> bool: ...
    def set_composite_space(self, composite_space: LayerColorSpace) -> bool: ...
    def set_edit_mask(self, edit_mask: bool) -> bool: ...
    def set_lock_alpha(self, lock_alpha: bool) -> bool: ...
    def set_mode(self, mode: LayerMode) -> bool: ...
    def set_offsets(self, offx: int, offy: int) -> bool: ...
    def set_opacity(self, opacity: float) -> bool: ...
    def set_show_mask(self, show_mask: bool) -> bool: ...


class LayerClass(GObject.GPointer):
    """
    :Constructors:

    ::

        LayerClass()
    """
    parent_class: DrawableClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class LayerMask(Channel):
    """
    :Constructors:

    ::

        LayerMask(**properties)

    Object GimpLayerMask

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    @staticmethod
    def get_by_id(layer_mask_id: int) -> typing.Optional[LayerMask]: ...


class LayerMaskClass(GObject.GPointer):
    """
    :Constructors:

    ::

        LayerMaskClass()
    """
    parent_class: ChannelClass = ...

class LoadProcedure(FileProcedure):
    """
    :Constructors:

    ::

        LoadProcedure(**properties)
        new(plug_in:Gimp.PlugIn, name:str, proc_type:Gimp.PDBProcType, run_func:Gimp.RunLoadFunc, run_data=None) -> Gimp.Procedure

    Object GimpLoadProcedure

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    parent_instance: FileProcedure = ...
    def __init__(self, name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    def get_handles_raw(self) -> bool: ...
    def get_thumbnail_loader(self) -> str: ...
    @classmethod
    def new(cls, plug_in: PlugIn, name: str, proc_type: PDBProcType, run_func: typing.Callable[..., typing.Tuple[ValueArray, MetadataLoadFlags]], *run_data: typing.Any) -> LoadProcedure: ...
    def set_handles_raw(self, handles_raw: bool) -> None: ...
    def set_thumbnail_loader(self, thumbnail_proc: str) -> None: ...


class LoadProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        LoadProcedureClass()
    """
    parent_class: FileProcedureClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class Matrix2(GObject.GBoxed):
    """
    :Constructors:

    ::

        Matrix2()
    """
    coeff: list[float] = ...
    def determinant(self) -> float: ...
    def identity(self) -> None: ...
    def invert(self) -> None: ...
    def mult(self, right: Matrix2) -> None: ...
    def transform_point(self, x: float, y: float) -> typing.Tuple[float, float]: ...


class Matrix3(GObject.GBoxed):
    """
    :Constructors:

    ::

        Matrix3()
    """
    coeff: list[float] = ...
    def affine(self, a: float, b: float, c: float, d: float, e: float, f: float) -> None: ...
    def determinant(self) -> float: ...
    def equal(self, matrix2: Matrix3) -> bool: ...
    def identity(self) -> None: ...
    def invert(self) -> None: ...
    def is_affine(self) -> bool: ...
    def is_diagonal(self) -> bool: ...
    def is_identity(self) -> bool: ...
    def is_simple(self) -> bool: ...
    def mult(self, right: Matrix3) -> None: ...
    def rotate(self, theta: float) -> None: ...
    def scale(self, x: float, y: float) -> None: ...
    def transform_point(self, x: float, y: float, newx: float, newy: float) -> None: ...
    def translate(self, x: float, y: float) -> None: ...
    def xshear(self, amount: float) -> None: ...
    def yshear(self, amount: float) -> None: ...


class Matrix4(GObject.GPointer):
    """
    :Constructors:

    ::

        Matrix4()
    """
    coeff: list[float] = ...
    def identity(self) -> None: ...
    def mult(self, right: Matrix4) -> None: ...
    def to_deg(self) -> typing.Tuple[float, float, float]: ...
    def transform_point(self, x: float, y: float, z: float) -> typing.Tuple[float, float, float, float]: ...


class Memsize:
    """
    :Constructors:

    ::

        Memsize(**properties)
    """
    @staticmethod
    def deserialize(string: str) -> typing.Tuple[bool, int]: ...
    @staticmethod
    def serialize(memsize: int) -> str: ...


class Metadata(GObject.Object):
    """
    :Constructors:

    ::

        Metadata(**properties)
        new() -> Gimp.Metadata

    Object GimpMetadata

    Signals from GObject:
      notify (GParam)
    """
    def add_xmp_history(self, state_status: str) -> None: ...
    @staticmethod
    def deserialize(metadata_xml: str) -> Metadata: ...
    def duplicate(self) -> Metadata: ...
    def get_colorspace(self) -> MetadataColorspace: ...
    @staticmethod
    def get_guid() -> str: ...
    def get_resolution(self) -> typing.Tuple[bool, float, float, Unit]: ...
    @staticmethod
    def is_tag_supported(tag: str, mime_type: str) -> bool: ...
    @staticmethod
    def load_from_file(file: Gio.File) -> Metadata: ...
    @classmethod
    def new(cls) -> Metadata: ...
    def save_to_file(self, file: Gio.File) -> bool: ...
    def serialize(self) -> str: ...
    def set_bits_per_sample(self, bits_per_sample: int) -> None: ...
    def set_colorspace(self, colorspace: MetadataColorspace) -> None: ...
    def set_creation_date(self, datetime: GLib.DateTime) -> None: ...
    def set_from_exif(self, exif_data: typing.Sequence[int]) -> bool: ...
    def set_from_iptc(self, iptc_data: typing.Sequence[int]) -> bool: ...
    def set_from_xmp(self, xmp_data: typing.Sequence[int]) -> bool: ...
    def set_pixel_size(self, width: int, height: int) -> None: ...
    def set_resolution(self, xres: float, yres: float, unit: Unit) -> None: ...


class MetadataClass(GObject.GPointer):
    """
    :Constructors:

    ::

        MetadataClass()
    """
    parent_class: None = ...

class Module(GObject.TypeModule, GObject.TypePlugin):
    """
    :Constructors:

    ::

        Module(**properties)
        new(file:Gio.File, auto_load:bool, verbose:bool) -> Gimp.Module

    Object GimpModule

    Properties from GimpModule:
      auto-load -> gboolean: auto-load
        auto-load
      on-disk -> gboolean: on-disk
        on-disk

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        auto_load: bool
        on_disk: bool
    props: Props = ...
    parent_instance: GObject.TypeModule = ...
    def __init__(self, auto_load: bool = ...) -> None: ...
    def do_modified(self) -> None: ...
    @staticmethod
    def error_quark() -> int: ...
    def get_auto_load(self) -> bool: ...
    def get_file(self) -> Gio.File: ...
    def get_info(self) -> ModuleInfo: ...
    def get_last_error(self) -> str: ...
    def get_state(self) -> ModuleState: ...
    def is_loaded(self) -> bool: ...
    def is_on_disk(self) -> bool: ...
    @classmethod
    def new(cls, file: Gio.File, auto_load: bool, verbose: bool) -> Module: ...
    @staticmethod
    def query(module: GObject.TypeModule) -> ModuleInfo: ...
    def query_module(self) -> bool: ...
    @staticmethod
    def register(module: GObject.TypeModule) -> bool: ...
    def set_auto_load(self, auto_load: bool) -> None: ...


class ModuleClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ModuleClass()
    """
    parent_class: GObject.TypeModuleClass = ...
    modified: typing.Callable[[Module], None] = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class ModuleDB(GObject.Object, Gio.ListModel):
    """
    :Constructors:

    ::

        ModuleDB(**properties)
        new(verbose:bool) -> Gimp.ModuleDB

    Object GimpModuleDB

    Signals from GListModel:
      items-changed (guint, guint, guint)

    Signals from GObject:
      notify (GParam)
    """
    def get_load_inhibit(self) -> str: ...
    def get_verbose(self) -> bool: ...
    def load(self, module_path: str) -> None: ...
    @classmethod
    def new(cls, verbose: bool) -> ModuleDB: ...
    def refresh(self, module_path: str) -> None: ...
    def set_load_inhibit(self, load_inhibit: str) -> None: ...
    def set_verbose(self, verbose: bool) -> None: ...


class ModuleDBClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ModuleDBClass()
    """
    parent_class: GObject.ObjectClass = ...

class ModuleInfo(GObject.GPointer):
    """
    :Constructors:

    ::

        ModuleInfo()
    """
    abi_version: int = ...
    purpose: str = ...
    author: str = ...
    version: str = ...
    copyright: str = ...
    date: str = ...

class PDB(GObject.Object):
    """
    :Constructors:

    ::

        PDB(**properties)

    Object GimpPDB

    Signals from GObject:
      notify (GParam)
    """
    def dump_to_file(self, file: Gio.File) -> bool: ...
    def get_last_error(self) -> str: ...
    def get_last_status(self) -> PDBStatusType: ...
    def lookup_procedure(self, procedure_name: str) -> typing.Optional[Procedure]: ...
    def procedure_exists(self, procedure_name: str) -> bool: ...
    def query_procedures(self, name: str, blurb: str, help: str, help_id: str, authors: str, copyright: str, date: str, proc_type: str) -> list[str]: ...
    def temp_procedure_name(self) -> str: ...


class PDBClass(GObject.GPointer):
    """
    :Constructors:

    ::

        PDBClass()
    """
    parent_class: GObject.ObjectClass = ...

class Palette(Resource, ConfigInterface):
    """
    :Constructors:

    ::

        Palette(**properties)
        new(name:str) -> Gimp.Palette

    Object GimpPalette

    Properties from GimpResource:
      id -> gint: The id
        The id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def add_entry(self, entry_name: typing.Optional[str], color: Gegl.Color) -> typing.Tuple[bool, int]: ...
    def delete_entry(self, entry_num: int) -> bool: ...
    @staticmethod
    def get_by_name(name: str) -> typing.Optional[Palette]: ...
    def get_color_count(self) -> int: ...
    def get_colormap(self, format: Babl.Object) -> typing.Tuple[bytes, int]: ...
    def get_colors(self) -> list[Gegl.Color]: ...
    def get_columns(self) -> int: ...
    def get_entry_color(self, entry_num: int) -> Gegl.Color: ...
    def get_entry_name(self, entry_num: int) -> typing.Tuple[bool, str]: ...
    @classmethod
    def new(cls, name: str) -> Palette: ...
    def set_colormap(self, format: Babl.Object, colormap: int, num_bytes: int) -> bool: ...
    def set_columns(self, columns: int) -> bool: ...
    def set_entry_color(self, entry_num: int, color: Gegl.Color) -> bool: ...
    def set_entry_name(self, entry_num: int, entry_name: typing.Optional[str] = None) -> bool: ...


class PaletteClass(GObject.GPointer):
    """
    :Constructors:

    ::

        PaletteClass()
    """
    parent_class: ResourceClass = ...

class ParamArray(GObject.ParamSpecBoxed): ...

class ParamBrush(ParamResource): ...

class ParamChannel(ParamDrawable): ...

class ParamChoice(GObject.ParamSpecString): ...

class ParamColor(ParamObject): ...

class ParamConfigPath(GObject.ParamSpecString): ...

class ParamCoreObjectArray(GObject.ParamSpecBoxed): ...

class ParamDisplay(GObject.ParamSpecObject): ...

class ParamDoubleArray(ParamArray): ...

class ParamDrawable(ParamItem): ...

class ParamDrawableFilter(GObject.ParamSpecObject): ...

class ParamExportOptions(GObject.ParamSpecObject): ...

class ParamFile(ParamObject): ...

class ParamFont(ParamResource): ...

class ParamGradient(ParamResource): ...

class ParamGroupLayer(ParamLayer): ...

class ParamImage(GObject.ParamSpecObject): ...

class ParamInt32Array(ParamArray): ...

class ParamItem(GObject.ParamSpecObject): ...

class ParamLayer(ParamDrawable): ...

class ParamLayerMask(ParamChannel): ...

class ParamMatrix2(GObject.ParamSpecBoxed): ...

class ParamMatrix3(GObject.ParamSpecBoxed): ...

class ParamMemsize(GObject.ParamSpecUInt64): ...

class ParamObject(GObject.ParamSpecObject): ...

class ParamPalette(ParamResource): ...

class ParamParasite(GObject.ParamSpecBoxed): ...

class ParamPath(ParamItem): ...

class ParamPattern(ParamResource): ...

class ParamResource(ParamObject): ...

class ParamSelection(ParamChannel): ...

class ParamSpecObject(GObject.GPointer):
    """
    :Constructors:

    ::

        ParamSpecObject()
    """
    parent_instance: GObject.ParamSpecObject = ...
    _default_value: GObject.Object = ...
    _has_default: bool = ...
    @staticmethod
    def duplicate(pspec: GObject.ParamSpec) -> GObject.ParamSpec: ...
    @staticmethod
    def get_default(pspec: GObject.ParamSpec) -> GObject.Object: ...
    @staticmethod
    def has_default(pspec: GObject.ParamSpec) -> bool: ...
    @staticmethod
    def set_default(pspec: GObject.ParamSpec, default_value: typing.Optional[GObject.Object] = None) -> None: ...


class ParamSpecObjectClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ParamSpecObjectClass()
    """
    parent_class: GObject.ParamSpecClass = ...
    duplicate: None = ...
    get_default: None = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class ParamTextLayer(ParamLayer): ...

class ParamUnit(ParamObject): ...

class ParamValueArray(GObject.ParamSpecBoxed): ...

class Parasite(GObject.GBoxed):
    """
    :Constructors:

    ::

        Parasite()
        new(name:str, flags:int, data:list=None) -> Gimp.Parasite
    """
    name: str = ...
    flags: int = ...
    size: int = ...
    data: list[None] = ...
    def compare(self, b: Parasite) -> bool: ...
    def copy(self) -> Parasite: ...
    def free(self) -> None: ...
    def get_data(self) -> list[int]: ...
    def get_flags(self) -> int: ...
    def get_name(self) -> str: ...
    def has_flag(self, flag: int) -> bool: ...
    def is_persistent(self) -> bool: ...
    def is_type(self, name: str) -> bool: ...
    def is_undoable(self) -> bool: ...
    @classmethod
    def new(cls, name: str, flags: int, data: typing.Optional[typing.Sequence[int]] = None) -> Parasite: ...


class Path(Item):
    """
    :Constructors:

    ::

        Path(**properties)
        new(image:Gimp.Image, name:str) -> Gimp.Path
        new_from_text_layer(image:Gimp.Image, layer:Gimp.Layer) -> Gimp.Path

    Object GimpPath

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def bezier_stroke_conicto(self, stroke_id: int, x0: float, y0: float, x1: float, y1: float) -> bool: ...
    def bezier_stroke_cubicto(self, stroke_id: int, x0: float, y0: float, x1: float, y1: float, x2: float, y2: float) -> bool: ...
    def bezier_stroke_lineto(self, stroke_id: int, x0: float, y0: float) -> bool: ...
    def bezier_stroke_new_ellipse(self, x0: float, y0: float, radius_x: float, radius_y: float, angle: float) -> int: ...
    def bezier_stroke_new_moveto(self, x0: float, y0: float) -> int: ...
    def copy(self) -> Path: ...
    @staticmethod
    def free(path: list[str]) -> None: ...
    @staticmethod
    def get_by_id(path_id: int) -> typing.Optional[Path]: ...
    def get_strokes(self) -> list[int]: ...
    @staticmethod
    def get_user_writable_dir(path: list[str]) -> str: ...
    @classmethod
    def new(cls, image: Image, name: str) -> Path: ...
    @classmethod
    def new_from_text_layer(cls, image: Image, layer: Layer) -> Path: ...
    @staticmethod
    def parse(path: str, max_paths: int, check: bool) -> typing.Tuple[list[str], list[str]]: ...
    def remove_stroke(self, stroke_id: int) -> bool: ...
    def stroke_close(self, stroke_id: int) -> bool: ...
    def stroke_flip(self, stroke_id: int, flip_type: OrientationType, axis: float) -> bool: ...
    def stroke_flip_free(self, stroke_id: int, x1: float, y1: float, x2: float, y2: float) -> bool: ...
    def stroke_get_length(self, stroke_id: int, precision: float) -> float: ...
    def stroke_get_point_at_dist(self, stroke_id: int, dist: float, precision: float) -> typing.Tuple[bool, float, float, float, bool]: ...
    def stroke_get_points(self, stroke_id: int) -> typing.Tuple[PathStrokeType, list[float], bool]: ...
    def stroke_interpolate(self, stroke_id: int, precision: float) -> typing.Tuple[list[float], bool]: ...
    def stroke_new_from_points(self, type: PathStrokeType, controlpoints: typing.Sequence[float], closed: bool) -> int: ...
    def stroke_reverse(self, stroke_id: int) -> bool: ...
    def stroke_rotate(self, stroke_id: int, center_x: float, center_y: float, angle: float) -> bool: ...
    def stroke_scale(self, stroke_id: int, scale_x: float, scale_y: float) -> bool: ...
    def stroke_translate(self, stroke_id: int, off_x: float, off_y: float) -> bool: ...
    @staticmethod
    def to_str(path: list[str]) -> str: ...


class PathClass(GObject.GPointer):
    """
    :Constructors:

    ::

        PathClass()
    """
    parent_class: ItemClass = ...

class Pattern(Resource, ConfigInterface):
    """
    :Constructors:

    ::

        Pattern(**properties)

    Object GimpPattern

    Properties from GimpResource:
      id -> gint: The id
        The id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def get_buffer(self, max_width: int, max_height: int, format: Babl.Object) -> Gegl.Buffer: ...
    @staticmethod
    def get_by_name(name: str) -> typing.Optional[Pattern]: ...
    def get_info(self) -> typing.Tuple[bool, int, int, int]: ...


class PatternClass(GObject.GPointer):
    """
    :Constructors:

    ::

        PatternClass()
    """
    parent_class: ResourceClass = ...

class PixPipeParams(GObject.GPointer):
    """
    :Constructors:

    ::

        PixPipeParams()
    """
    step: int = ...
    ncells: int = ...
    dim: int = ...
    cols: int = ...
    rows: int = ...
    cellwidth: int = ...
    cellheight: int = ...
    placement: str = ...
    rank: list[int] = ...
    selection: list[str] = ...

class PlugIn(GObject.Object):
    """
    :Constructors:

    ::

        PlugIn(**properties)

    Object GimpPlugIn

    Properties from GimpPlugIn:
      program-name -> gchararray: The plug-in executable
        The executable name as usually found on argv[0]
      read-channel -> GIOChannel: Read channel
        The GIOChanel to read from GIMP
      write-channel -> GIOChannel: Write channel
        The GIOChanel to write to GIMP

    Signals from GObject:
      notify (GParam)
    """
    __gtype__: typing.Any
    class Props:
        read_channel: GLib.IOChannel
        write_channel: GLib.IOChannel
        program_name: str
    props: Props = ...
    parent_instance: GObject.Object = ...
    def __init__(self, program_name: str = ...,
                 read_channel: GLib.IOChannel = ...,
                 write_channel: GLib.IOChannel = ...) -> None: ...
    def add_menu_branch(self, menu_path: str, menu_label: str) -> None: ...
    def add_temp_procedure(self, procedure: Procedure) -> None: ...
    @staticmethod
    def directory() -> str: ...
    def do_create_procedure(self, procedure_name: str) -> Procedure: ...
    def do_init_procedures(self) -> list[str]: ...
    def do_query_procedures(self) -> list[str]: ...
    def do_quit(self) -> None: ...
    def do_set_i18n(self, procedure_name: str) -> typing.Tuple[bool, str, str]: ...
    @staticmethod
    def error_quark() -> int: ...
    def get_pdb_error_handler(self) -> PDBErrorHandler: ...
    def get_temp_procedure(self, procedure_name: str) -> typing.Optional[Procedure]: ...
    def get_temp_procedures(self) -> list[Procedure]: ...
    def persistent_enable(self) -> None: ...
    def persistent_process(self, timeout: int) -> None: ...
    def remove_temp_procedure(self, procedure_name: str) -> None: ...
    def set_help_domain(self, domain_name: str, domain_uri: Gio.File) -> None: ...
    def set_pdb_error_handler(self, handler: PDBErrorHandler) -> None: ...


class PlugInClass(GObject.GPointer):
    """
    :Constructors:

    ::

        PlugInClass()
    """
    parent_class: GObject.ObjectClass = ...
    query_procedures: typing.Callable[[PlugIn], list[str]] = ...
    init_procedures: typing.Callable[[PlugIn], list[str]] = ...
    create_procedure: typing.Callable[[PlugIn, str], Procedure] = ...
    quit: typing.Callable[[PlugIn], None] = ...
    set_i18n: typing.Callable[[PlugIn, str], typing.Tuple[bool, str, str]] = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class Procedure(GObject.Object):
    """
    :Constructors:

    ::

        Procedure(**properties)
        new(plug_in:Gimp.PlugIn, name:str, proc_type:Gimp.PDBProcType, run_func:Gimp.RunFunc, run_data=None) -> Gimp.Procedure

    Object GimpProcedure

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    parent_instance: GObject.Object = ...
    def __init__(self, name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    def add_boolean_argument(self, name: str, nick: str, blurb: typing.Optional[str], value: bool, flags: GObject.ParamFlags) -> None: ...
    def add_boolean_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], value: bool, flags: GObject.ParamFlags) -> None: ...
    def add_boolean_return_value(self, name: str, nick: str, blurb: typing.Optional[str], value: bool, flags: GObject.ParamFlags) -> None: ...
    def add_brush_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, default_value: typing.Optional[Brush], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_brush_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], default_value: typing.Optional[Brush], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_brush_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_bytes_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_bytes_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_bytes_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_channel_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_channel_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_channel_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_choice_argument(self, name: str, nick: str, blurb: typing.Optional[str], choice: Choice, value: str, flags: GObject.ParamFlags) -> None: ...
    def add_choice_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], choice: Choice, value: str, flags: GObject.ParamFlags) -> None: ...
    def add_choice_return_value(self, name: str, nick: str, blurb: typing.Optional[str], choice: Choice, value: str, flags: GObject.ParamFlags) -> None: ...
    def add_color_argument(self, name: str, nick: str, blurb: typing.Optional[str], has_alpha: bool, value: Gegl.Color, flags: GObject.ParamFlags) -> None: ...
    def add_color_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], has_alpha: bool, value: Gegl.Color, flags: GObject.ParamFlags) -> None: ...
    def add_color_from_string_argument(self, name: str, nick: str, blurb: typing.Optional[str], has_alpha: bool, value: str, flags: GObject.ParamFlags) -> None: ...
    def add_color_from_string_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], has_alpha: bool, value: str, flags: GObject.ParamFlags) -> None: ...
    def add_color_from_string_return_value(self, name: str, nick: str, blurb: typing.Optional[str], has_alpha: bool, value: str, flags: GObject.ParamFlags) -> None: ...
    def add_color_return_value(self, name: str, nick: str, blurb: typing.Optional[str], has_alpha: bool, value: Gegl.Color, flags: GObject.ParamFlags) -> None: ...
    def add_core_object_array_argument(self, name: str, nick: str, blurb: typing.Optional[str], object_type: typing.Type[typing.Any], flags: GObject.ParamFlags) -> None: ...
    def add_core_object_array_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], object_type: typing.Type[typing.Any], flags: GObject.ParamFlags) -> None: ...
    def add_core_object_array_return_value(self, name: str, nick: str, blurb: typing.Optional[str], object_type: typing.Type[typing.Any], flags: GObject.ParamFlags) -> None: ...
    def add_display_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_display_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_display_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_double_argument(self, name: str, nick: str, blurb: typing.Optional[str], min: float, max: float, value: float, flags: GObject.ParamFlags) -> None: ...
    def add_double_array_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_double_array_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_double_array_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_double_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], min: float, max: float, value: float, flags: GObject.ParamFlags) -> None: ...
    def add_double_return_value(self, name: str, nick: str, blurb: typing.Optional[str], min: float, max: float, value: float, flags: GObject.ParamFlags) -> None: ...
    def add_drawable_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_drawable_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_drawable_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_enum_argument(self, name: str, nick: str, blurb: typing.Optional[str], enum_type: typing.Type[typing.Any], value: int, flags: GObject.ParamFlags) -> None: ...
    def add_enum_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], enum_type: typing.Type[typing.Any], value: int, flags: GObject.ParamFlags) -> None: ...
    def add_enum_return_value(self, name: str, nick: str, blurb: typing.Optional[str], enum_type: typing.Type[typing.Any], value: int, flags: GObject.ParamFlags) -> None: ...
    def add_file_argument(self, name: str, nick: str, blurb: typing.Optional[str], action: FileChooserAction, none_ok: bool, default_file: typing.Optional[Gio.File], flags: GObject.ParamFlags) -> None: ...
    def add_file_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], action: FileChooserAction, none_ok: bool, default_file: typing.Optional[Gio.File], flags: GObject.ParamFlags) -> None: ...
    def add_file_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_font_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, default_value: typing.Optional[Font], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_font_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], default_value: typing.Optional[Font], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_font_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_gradient_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, default_value: typing.Optional[Gradient], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_gradient_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], default_value: typing.Optional[Gradient], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_gradient_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_group_layer_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_group_layer_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_group_layer_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_image_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_image_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_image_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_int32_array_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_int32_array_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_int32_array_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_int_argument(self, name: str, nick: str, blurb: typing.Optional[str], min: int, max: int, value: int, flags: GObject.ParamFlags) -> None: ...
    def add_int_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], min: int, max: int, value: int, flags: GObject.ParamFlags) -> None: ...
    def add_int_return_value(self, name: str, nick: str, blurb: typing.Optional[str], min: int, max: int, value: int, flags: GObject.ParamFlags) -> None: ...
    def add_item_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_item_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_item_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_layer_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_layer_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_layer_mask_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_layer_mask_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_layer_mask_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_layer_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_menu_path(self, menu_path: str) -> None: ...
    def add_palette_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, default_value: typing.Optional[Palette], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_palette_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], default_value: typing.Optional[Palette], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_palette_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_param_argument(self, name: str, nick: str, blurb: typing.Optional[str], param_type: typing.Type[typing.Any], flags: GObject.ParamFlags) -> None: ...
    def add_param_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], param_type: typing.Type[typing.Any], flags: GObject.ParamFlags) -> None: ...
    def add_param_return_value(self, name: str, nick: str, blurb: typing.Optional[str], param_type: typing.Type[typing.Any], flags: GObject.ParamFlags) -> None: ...
    def add_parasite_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_parasite_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_parasite_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_path_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_path_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_path_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_pattern_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, default_value: typing.Optional[Pattern], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_pattern_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], default_value: typing.Optional[Pattern], default_to_context: bool, flags: GObject.ParamFlags) -> None: ...
    def add_pattern_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_resource_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, default_value: typing.Optional[Resource], flags: GObject.ParamFlags) -> None: ...
    def add_resource_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], default_value: typing.Optional[Resource], flags: GObject.ParamFlags) -> None: ...
    def add_resource_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_selection_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_selection_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_selection_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_string_argument(self, name: str, nick: str, blurb: typing.Optional[str], value: str, flags: GObject.ParamFlags) -> None: ...
    def add_string_array_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_string_array_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_string_array_return_value(self, name: str, nick: str, blurb: typing.Optional[str], flags: GObject.ParamFlags) -> None: ...
    def add_string_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], value: str, flags: GObject.ParamFlags) -> None: ...
    def add_string_return_value(self, name: str, nick: str, blurb: typing.Optional[str], value: str, flags: GObject.ParamFlags) -> None: ...
    def add_text_layer_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_text_layer_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_text_layer_return_value(self, name: str, nick: str, blurb: typing.Optional[str], none_ok: bool, flags: GObject.ParamFlags) -> None: ...
    def add_uint_argument(self, name: str, nick: str, blurb: typing.Optional[str], min: int, max: int, value: int, flags: GObject.ParamFlags) -> None: ...
    def add_uint_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], min: int, max: int, value: int, flags: GObject.ParamFlags) -> None: ...
    def add_uint_return_value(self, name: str, nick: str, blurb: typing.Optional[str], min: int, max: int, value: int, flags: GObject.ParamFlags) -> None: ...
    def add_unit_argument(self, name: str, nick: str, blurb: typing.Optional[str], show_pixels: bool, show_percent: bool, value: Unit, flags: GObject.ParamFlags) -> None: ...
    def add_unit_aux_argument(self, name: str, nick: str, blurb: typing.Optional[str], show_pixels: bool, show_percent: bool, value: Unit, flags: GObject.ParamFlags) -> None: ...
    def add_unit_return_value(self, name: str, nick: str, blurb: typing.Optional[str], show_pixels: bool, show_percent: bool, value: Unit, flags: GObject.ParamFlags) -> None: ...
    def create_config(self) -> ProcedureConfig: ...
    def do_install(self) -> None: ...
    def do_run(self, args: ValueArray) -> ValueArray: ...
    def do_set_sensitivity(self, sensitivity_mask: int) -> bool: ...
    def do_uninstall(self) -> None: ...
    def find_argument(self, name: str) -> GObject.ParamSpec: ...
    def find_aux_argument(self, name: str) -> GObject.ParamSpec: ...
    def find_return_value(self, name: str) -> GObject.ParamSpec: ...
    def get_argument_sync(self, arg_name: str) -> ArgumentSync: ...
    def get_arguments(self) -> list[GObject.ParamSpec]: ...
    def get_authors(self) -> str: ...
    def get_aux_arguments(self) -> list[GObject.ParamSpec]: ...
    def get_blurb(self) -> str: ...
    def get_copyright(self) -> str: ...
    def get_date(self) -> str: ...
    def get_help(self) -> str: ...
    def get_help_id(self) -> str: ...
    def get_icon_file(self) -> typing.Optional[Gio.File]: ...
    def get_icon_name(self) -> typing.Optional[str]: ...
    def get_icon_pixbuf(self) -> typing.Optional[GdkPixbuf.Pixbuf]: ...
    def get_icon_type(self) -> IconType: ...
    def get_image_types(self) -> str: ...
    def get_menu_label(self) -> str: ...
    def get_menu_paths(self) -> list[str]: ...
    def get_name(self) -> str: ...
    def get_plug_in(self) -> PlugIn: ...
    def get_proc_type(self) -> PDBProcType: ...
    def get_return_values(self) -> list[GObject.ParamSpec]: ...
    def get_sensitivity_mask(self) -> int: ...
    def is_internal(self) -> bool: ...
    @classmethod
    def new(cls, plug_in: PlugIn, name: str, proc_type: PDBProcType, run_func: typing.Callable[..., ValueArray], *run_data: typing.Any) -> Procedure: ...
    def new_return_values(self, status: PDBStatusType, error: typing.Optional[GLib.Error] = None) -> ValueArray: ...
    def persistent_ready(self) -> None: ...
    def run(self, config: typing.Optional[ProcedureConfig] = None) -> ValueArray: ...
    def set_argument_sync(self, arg_name: str, sync: ArgumentSync) -> None: ...
    def set_attribution(self, authors: str, copyright: str, date: str) -> None: ...
    def set_documentation(self, blurb: str, help: typing.Optional[str] = None, help_id: typing.Optional[str] = None) -> None: ...
    def set_icon_file(self, file: typing.Optional[Gio.File] = None) -> None: ...
    def set_icon_name(self, icon_name: typing.Optional[str] = None) -> None: ...
    def set_icon_pixbuf(self, pixbuf: typing.Optional[GdkPixbuf.Pixbuf] = None) -> None: ...
    def set_image_types(self, image_types: str) -> None: ...
    def set_menu_label(self, menu_label: str) -> None: ...
    def set_sensitivity_mask(self, sensitivity_mask: int) -> None: ...


class ProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ProcedureClass()
    """
    parent_class: GObject.ObjectClass = ...
    install: typing.Callable[[Procedure], None] = ...
    uninstall: typing.Callable[[Procedure], None] = ...
    run: typing.Callable[[Procedure, ValueArray], ValueArray] = ...
    create_config: None = ...
    set_sensitivity: typing.Callable[[Procedure, int], bool] = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class ProcedureConfig(GObject.Object):
    """
    :Constructors:

    ::

        ProcedureConfig(**properties)

    Object GimpProcedureConfig

    Properties from GimpProcedureConfig:
      procedure -> GimpProcedure: Procedure
        The procedure this config object is used for

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        procedure: Procedure
    props: Props = ...
    parent_instance: GObject.Object = ...
    def __init__(self, procedure: Procedure = ...) -> None: ...
    def get_choice_id(self, property_name: str) -> int: ...
    def get_color_array(self, property_name: str) -> list[Gegl.Color]: ...
    def get_core_object_array(self, property_name: str) -> list[GObject.Object]: ...
    def get_procedure(self) -> Procedure: ...
    def save_metadata(self, exported_image: Image, file: Gio.File) -> None: ...
    def set_color_array(self, property_name: str, colors: typing.Sequence[Gegl.Color]) -> None: ...
    def set_core_object_array(self, property_name: str, objects: typing.Sequence[GObject.Object]) -> None: ...


class ProcedureConfigClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ProcedureConfigClass()
    """
    parent_class: GObject.ObjectClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class ProgressVtable(GObject.GPointer):
    """
    :Constructors:

    ::

        ProgressVtable()
    """
    start: typing.Callable[..., None] = ...
    end: typing.Callable[..., None] = ...
    set_text: typing.Callable[..., None] = ...
    set_value: typing.Callable[..., None] = ...
    pulse: typing.Callable[..., None] = ...
    get_window_handle: typing.Callable[..., GLib.Bytes] = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class Resource(GObject.Object, ConfigInterface):
    """
    :Constructors:

    ::

        Resource(**properties)

    Object GimpResource

    Properties from GimpResource:
      id -> gint: The id
        The id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    parent_instance: GObject.Object = ...
    def __init__(self, id: int = ...) -> None: ...
    def delete(self) -> bool: ...
    def duplicate(self) -> Resource: ...
    @staticmethod
    def get_by_id(resource_id: int) -> typing.Optional[Resource]: ...
    @staticmethod
    def get_by_name(resource_type: typing.Type[typing.Any], resource_name: str) -> typing.Optional[Resource]: ...
    def get_id(self) -> int: ...
    def get_name(self) -> str: ...
    @staticmethod
    def id_is_brush(resource_id: int) -> bool: ...
    @staticmethod
    def id_is_font(resource_id: int) -> bool: ...
    @staticmethod
    def id_is_gradient(resource_id: int) -> bool: ...
    @staticmethod
    def id_is_palette(resource_id: int) -> bool: ...
    @staticmethod
    def id_is_pattern(resource_id: int) -> bool: ...
    @staticmethod
    def id_is_valid(resource_id: int) -> bool: ...
    def is_brush(self) -> bool: ...
    def is_editable(self) -> bool: ...
    def is_font(self) -> bool: ...
    def is_gradient(self) -> bool: ...
    def is_palette(self) -> bool: ...
    def is_pattern(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def rename(self, new_name: str) -> bool: ...


class ResourceClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ResourceClass()
    """
    parent_class: GObject.ObjectClass = ...
    _gimp_reserved0: None = ...
    _gimp_reserved1: None = ...
    _gimp_reserved2: None = ...
    _gimp_reserved3: None = ...
    _gimp_reserved4: None = ...
    _gimp_reserved5: None = ...
    _gimp_reserved6: None = ...
    _gimp_reserved7: None = ...
    _gimp_reserved8: None = ...
    _gimp_reserved9: None = ...

class Scanner(GObject.GBoxed):
    """
    :Constructors:

    ::

        new_file(file:Gio.File) -> Gimp.Scanner
        new_stream(input:Gio.InputStream) -> Gimp.Scanner
        new_string(text:list) -> Gimp.Scanner
    """
    @classmethod
    def new_file(cls, file: Gio.File) -> Scanner: ...
    @classmethod
    def new_stream(cls, input: Gio.InputStream) -> Scanner: ...
    @classmethod
    def new_string(cls, text: typing.Sequence[str]) -> Scanner: ...
    def parse_boolean(self) -> typing.Tuple[bool, bool]: ...
    def parse_color(self) -> typing.Tuple[bool, Gegl.Color]: ...
    def parse_data(self) -> typing.Tuple[bool, bytes]: ...
    def parse_double(self) -> typing.Tuple[bool, float]: ...
    def parse_identifier(self) -> typing.Tuple[bool, str]: ...
    def parse_int(self) -> typing.Tuple[bool, int]: ...
    def parse_int64(self) -> typing.Tuple[bool, int]: ...
    def parse_matrix2(self) -> typing.Tuple[bool, Matrix2]: ...
    def parse_string(self) -> typing.Tuple[bool, str]: ...
    def parse_string_no_validate(self) -> typing.Tuple[bool, str]: ...
    def parse_token(self, token: GLib.TokenType) -> bool: ...
    def ref(self) -> Scanner: ...
    def unref(self) -> None: ...


class Selection(Channel):
    """
    :Constructors:

    ::

        Selection(**properties)

    Object GimpSelection

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    @staticmethod
    def all(image: Image) -> bool: ...
    @staticmethod
    def border(image: Image, radius: int) -> bool: ...
    @staticmethod
    def bounds(image: Image) -> typing.Tuple[bool, bool, int, int, int, int]: ...
    @staticmethod
    def feather(image: Image, radius: float) -> bool: ...
    @staticmethod
    def float(image: Image, drawables: typing.Sequence[Drawable], offx: int, offy: int) -> Layer: ...
    @staticmethod
    def flood(image: Image) -> bool: ...
    @staticmethod
    def get_by_id(selection_id: int) -> typing.Optional[Selection]: ...
    @staticmethod
    def grow(image: Image, steps: int) -> bool: ...
    @staticmethod
    def invert(image: Image) -> bool: ...
    @staticmethod
    def is_empty(image: Image) -> bool: ...
    @staticmethod
    def none(image: Image) -> bool: ...
    @staticmethod
    def save(image: Image) -> Channel: ...
    @staticmethod
    def sharpen(image: Image) -> bool: ...
    @staticmethod
    def shrink(image: Image, steps: int) -> bool: ...
    @staticmethod
    def translate(image: Image, offx: int, offy: int) -> bool: ...
    @staticmethod
    def value(image: Image, x: int, y: int) -> int: ...


class SelectionClass(GObject.GPointer):
    """
    :Constructors:

    ::

        SelectionClass()
    """
    parent_class: ChannelClass = ...

class TextLayer(Layer):
    """
    :Constructors:

    ::

        TextLayer(**properties)
        new(image:Gimp.Image, text:str, font:Gimp.Font, size:float, unit:Gimp.Unit) -> Gimp.TextLayer

    Object GimpTextLayer

    Properties from GimpItem:
      id -> gint: The item id
        The item id for internal use

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        id: int
    props: Props = ...
    def __init__(self, id: int = ...) -> None: ...
    def get_antialias(self) -> bool: ...
    def get_base_direction(self) -> TextDirection: ...
    @staticmethod
    def get_by_id(layer_id: int) -> typing.Optional[TextLayer]: ...
    def get_color(self) -> Gegl.Color: ...
    def get_font(self) -> Font: ...
    def get_font_size(self) -> typing.Tuple[float, Unit]: ...
    def get_hint_style(self) -> TextHintStyle: ...
    def get_indent(self) -> float: ...
    def get_justification(self) -> TextJustification: ...
    def get_kerning(self) -> bool: ...
    def get_language(self) -> str: ...
    def get_letter_spacing(self) -> float: ...
    def get_line_spacing(self) -> float: ...
    def get_markup(self) -> str: ...
    def get_text(self) -> str: ...
    @classmethod
    def new(cls, image: Image, text: str, font: Font, size: float, unit: Unit) -> TextLayer: ...
    def resize(self, width: float, height: float) -> bool: ...
    def set_antialias(self, antialias: bool) -> bool: ...
    def set_base_direction(self, direction: TextDirection) -> bool: ...
    def set_color(self, color: Gegl.Color) -> bool: ...
    def set_font(self, font: Font) -> bool: ...
    def set_font_size(self, font_size: float, unit: Unit) -> bool: ...
    def set_hint_style(self, style: TextHintStyle) -> bool: ...
    def set_indent(self, indent: float) -> bool: ...
    def set_justification(self, justify: TextJustification) -> bool: ...
    def set_kerning(self, kerning: bool) -> bool: ...
    def set_language(self, language: str) -> bool: ...
    def set_letter_spacing(self, letter_spacing: float) -> bool: ...
    def set_line_spacing(self, line_spacing: float) -> bool: ...
    def set_markup(self, markup: str) -> bool: ...
    def set_text(self, text: str) -> bool: ...


class TextLayerClass(GObject.GPointer):
    """
    :Constructors:

    ::

        TextLayerClass()
    """
    parent_class: LayerClass = ...

class ThumbnailProcedure(Procedure):
    """
    :Constructors:

    ::

        ThumbnailProcedure(**properties)
        new(plug_in:Gimp.PlugIn, name:str, proc_type:Gimp.PDBProcType, run_func:Gimp.RunThumbnailFunc, run_data=None) -> Gimp.Procedure

    Object GimpThumbnailProcedure

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    def __init__(self, name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    @classmethod
    def new(cls, plug_in: PlugIn, name: str, proc_type: PDBProcType, run_func: typing.Callable[..., ValueArray], *run_data: typing.Any) -> ThumbnailProcedure: ...


class ThumbnailProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ThumbnailProcedureClass()
    """
    parent_class: ProcedureClass = ...

class Unit(GObject.Object):
    """
    :Constructors:

    ::

        Unit(**properties)
        new(name:str, factor:float, digits:int, symbol:str, abbreviation:str) -> Gimp.Unit

    Object GimpUnit

    Properties from GimpUnit:
      id -> gint: id
      name -> gchararray: name
      factor -> gdouble: factor
      digits -> gint: digits
      symbol -> gchararray: symbol
      abbreviation -> gchararray: abbreviation

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        abbreviation: str
        digits: int
        factor: float
        id: int
        name: str
        symbol: str
    props: Props = ...
    def __init__(self, abbreviation: str = ...,
                 digits: int = ...,
                 factor: float = ...,
                 id: int = ...,
                 name: str = ...,
                 symbol: str = ...) -> None: ...
    @staticmethod
    def format_string(format: str, unit: Unit) -> str: ...
    def get_abbreviation(self) -> str: ...
    @staticmethod
    def get_by_id(unit_id: int) -> Unit: ...
    def get_deletion_flag(self) -> bool: ...
    def get_digits(self) -> int: ...
    def get_factor(self) -> float: ...
    def get_id(self) -> int: ...
    def get_name(self) -> str: ...
    def get_scaled_digits(self, resolution: float) -> int: ...
    def get_symbol(self) -> str: ...
    @staticmethod
    def inch() -> Unit: ...
    def is_built_in(self) -> bool: ...
    def is_metric(self) -> bool: ...
    @staticmethod
    def mm() -> Unit: ...
    @classmethod
    def new(cls, name: str, factor: float, digits: int, symbol: str, abbreviation: str) -> Unit: ...
    @staticmethod
    def percent() -> Unit: ...
    @staticmethod
    def pica() -> Unit: ...
    @staticmethod
    def pixel() -> Unit: ...
    @staticmethod
    def point() -> Unit: ...
    def set_deletion_flag(self, deletion_flag: bool) -> None: ...


class UnitClass(GObject.GPointer):
    """
    :Constructors:

    ::

        UnitClass()
    """
    parent_class: GObject.ObjectClass = ...

class ValueArray(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(n_prealloced:int) -> Gimp.ValueArray
        new_from_values(values:list) -> Gimp.ValueArray
    """
    def append(self, value: typing.Optional[typing.Any] = None) -> ValueArray: ...
    def copy(self) -> ValueArray: ...
    def get_color_array(self, index: int) -> list[Gegl.Color]: ...
    def get_core_object_array(self, index: int) -> list[GObject.Object]: ...
    def index(self, index: int) -> typing.Any: ...
    def insert(self, index: int, value: typing.Optional[typing.Any] = None) -> ValueArray: ...
    def length(self) -> int: ...
    @classmethod
    def new(cls, n_prealloced: int) -> ValueArray: ...
    @classmethod
    def new_from_values(cls, values: typing.Sequence[typing.Any]) -> ValueArray: ...
    def prepend(self, value: typing.Optional[typing.Any] = None) -> ValueArray: ...
    def ref(self) -> ValueArray: ...
    def remove(self, index: int) -> ValueArray: ...
    def truncate(self, n_values: int) -> None: ...
    def unref(self) -> None: ...


class Vector2(GObject.GBoxed):
    """
    :Constructors:

    ::

        Vector2()
        new(x:float, y:float) -> Gimp.Vector2
    """
    x: float = ...
    y: float = ...
    @staticmethod
    def add(vector1: Vector2, vector2: Vector2) -> Vector2: ...
    def add_val(self, vector2: Vector2) -> Vector2: ...
    def cross_product(self, vector2: Vector2) -> Vector2: ...
    def cross_product_val(self, vector2: Vector2) -> Vector2: ...
    def inner_product(self, vector2: Vector2) -> float: ...
    def inner_product_val(self, vector2: Vector2) -> float: ...
    def length(self) -> float: ...
    def length_val(self) -> float: ...
    def mul(self, factor: float) -> None: ...
    def mul_val(self, factor: float) -> Vector2: ...
    def neg(self) -> None: ...
    def neg_val(self) -> Vector2: ...
    @classmethod
    def new(cls, x: float, y: float) -> Vector2: ...
    def normal(self) -> Vector2: ...
    def normal_val(self) -> Vector2: ...
    def normalize(self) -> None: ...
    def normalize_val(self) -> Vector2: ...
    def rotate(self, alpha: float) -> None: ...
    def rotate_val(self, alpha: float) -> Vector2: ...
    def set(self, x: float, y: float) -> None: ...
    @staticmethod
    def sub(vector1: Vector2, vector2: Vector2) -> Vector2: ...
    def sub_val(self, vector2: Vector2) -> Vector2: ...


class Vector3(GObject.GBoxed):
    """
    :Constructors:

    ::

        Vector3()
        new(x:float, y:float, z:float) -> Gimp.Vector3
    """
    x: float = ...
    y: float = ...
    z: float = ...
    @staticmethod
    def add(vector1: Vector3, vector2: Vector3) -> Vector3: ...
    def add_val(self, vector2: Vector3) -> Vector3: ...
    def cross_product(self, vector2: Vector3) -> Vector3: ...
    def cross_product_val(self, vector2: Vector3) -> Vector3: ...
    def inner_product(self, vector2: Vector3) -> float: ...
    def inner_product_val(self, vector2: Vector3) -> float: ...
    def length(self) -> float: ...
    def length_val(self) -> float: ...
    def mul(self, factor: float) -> None: ...
    def mul_val(self, factor: float) -> Vector3: ...
    def neg(self) -> None: ...
    def neg_val(self) -> Vector3: ...
    @classmethod
    def new(cls, x: float, y: float, z: float) -> Vector3: ...
    def normalize(self) -> None: ...
    def normalize_val(self) -> Vector3: ...
    def rotate(self, alpha: float, beta: float, gamma: float) -> None: ...
    def rotate_val(self, alpha: float, beta: float, gamma: float) -> Vector3: ...
    def set(self, x: float, y: float, z: float) -> None: ...
    @staticmethod
    def sub(vector1: Vector3, vector2: Vector3) -> Vector3: ...
    def sub_val(self, vector2: Vector3) -> Vector3: ...


class Vector4(GObject.GPointer):
    """
    :Constructors:

    ::

        Vector4()
    """
    x: float = ...
    y: float = ...
    z: float = ...
    w: float = ...

class VectorLoadData(GObject.GPointer):
    """
    :Constructors:

    ::

        VectorLoadData()
    """
    width: float = ...
    width_unit: Unit = ...
    exact_width: bool = ...
    height: float = ...
    height_unit: Unit = ...
    exact_height: bool = ...
    correct_ratio: bool = ...
    pixel_density: float = ...
    density_unit: Unit = ...
    exact_density: bool = ...

class VectorLoadProcedure(LoadProcedure):
    """
    :Constructors:

    ::

        VectorLoadProcedure(**properties)
        new(plug_in:Gimp.PlugIn, name:str, proc_type:Gimp.PDBProcType, extract_func:Gimp.ExtractVectorFunc, extract_data=None, run_func:Gimp.RunVectorLoadFunc, run_data=None) -> Gimp.Procedure

    Object GimpVectorLoadProcedure

    Properties from GimpProcedure:
      plug-in -> GimpPlugIn: Plug-In
        The GimpPlugIn of this plug-in process
      name -> gchararray: Name
        The procedure's name
      procedure-type -> GimpPDBProcType: Procedure type
        The procedure's type

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        name: str
        plug_in: PlugIn
        procedure_type: PDBProcType
    props: Props = ...
    def __init__(self, name: str = ...,
                 plug_in: PlugIn = ...,
                 procedure_type: PDBProcType = ...) -> None: ...
    def extract_dimensions(self, file: Gio.File) -> typing.Tuple[bool, VectorLoadData]: ...
    @classmethod
    def new(cls, plug_in: PlugIn, name: str, proc_type: PDBProcType, extract_func: typing.Callable[..., typing.Tuple[bool, VectorLoadData, None, typing.Callable[[None], None]]], run_func: typing.Callable[..., typing.Tuple[ValueArray, MetadataLoadFlags]], *run_data: typing.Any) -> VectorLoadProcedure: ...


class VectorLoadProcedureClass(GObject.GPointer):
    """
    :Constructors:

    ::

        VectorLoadProcedureClass()
    """
    parent_class: LoadProcedureClass = ...

class ExportCapabilities(GObject.GFlags):
    CAN_HANDLE_ALPHA = 16
    CAN_HANDLE_BITMAP = 8
    CAN_HANDLE_GRAY = 2
    CAN_HANDLE_INDEXED = 4
    CAN_HANDLE_LAYERS = 32
    CAN_HANDLE_LAYERS_AS_ANIMATION = 64
    CAN_HANDLE_LAYER_EFFECTS = 256
    CAN_HANDLE_LAYER_MASKS = 128
    CAN_HANDLE_RGB = 1
    NEEDS_ALPHA = 512
    NEEDS_CROP = 1024

class MetadataLoadFlags(GObject.GFlags):
    ALL = 4294967295
    COLORSPACE = 8
    COMMENT = 1
    NONE = 0
    ORIENTATION = 4
    RESOLUTION = 2

class MetadataSaveFlags(GObject.GFlags):
    ALL = 4294967295
    COLOR_PROFILE = 16
    COMMENT = 32
    EXIF = 1
    IPTC = 4
    THUMBNAIL = 8
    XMP = 2

class ProcedureSensitivityMask(GObject.GFlags):
    ALWAYS = 2147483647
    DRAWABLE = 1
    DRAWABLES = 4
    NO_DRAWABLES = 8
    NO_IMAGE = 16

class AddMaskType(GObject.GEnum):
    ALPHA = 2
    ALPHA_TRANSFER = 3
    BLACK = 1
    CHANNEL = 6
    COPY = 5
    SELECTION = 4
    WHITE = 0

class ArgumentSync(GObject.GEnum):
    NONE = 0
    PARASITE = 1

class BrushApplicationMode(GObject.GEnum):
    HARD = 0
    SOFT = 1

class BrushGeneratedShape(GObject.GEnum):
    CIRCLE = 0
    DIAMOND = 2
    SQUARE = 1

class CapStyle(GObject.GEnum):
    BUTT = 0
    ROUND = 1
    SQUARE = 2

class ChannelOps(GObject.GEnum):
    ADD = 0
    INTERSECT = 3
    REPLACE = 2
    SUBTRACT = 1

class ChannelType(GObject.GEnum):
    ALPHA = 5
    BLUE = 2
    GRAY = 3
    GREEN = 1
    INDEXED = 4
    RED = 0

class CheckSize(GObject.GEnum):
    LARGE_CHECKS = 2
    MEDIUM_CHECKS = 1
    SMALL_CHECKS = 0

class CheckType(GObject.GEnum):
    BLACK_ONLY = 5
    CUSTOM_CHECKS = 6
    DARK_CHECKS = 2
    GRAY_CHECKS = 1
    GRAY_ONLY = 4
    LIGHT_CHECKS = 0
    WHITE_ONLY = 3

class CloneType(GObject.GEnum):
    IMAGE = 0
    PATTERN = 1

class ColorManagementMode(GObject.GEnum):
    DISPLAY = 1
    OFF = 0
    SOFTPROOF = 2

class ColorRenderingIntent(GObject.GEnum):
    ABSOLUTE_COLORIMETRIC = 3
    PERCEPTUAL = 0
    RELATIVE_COLORIMETRIC = 1
    SATURATION = 2

class ColorTag(GObject.GEnum):
    BLUE = 1
    BROWN = 5
    GRAY = 8
    GREEN = 2
    NONE = 0
    ORANGE = 4
    RED = 6
    VIOLET = 7
    YELLOW = 3

class ColorTransformFlags(GObject.GEnum):
    BLACK_POINT_COMPENSATION = 8192
    GAMUT_CHECK = 4096
    NOOPTIMIZE = 256

class ComponentType(GObject.GEnum):
    DOUBLE = 700
    FLOAT = 600
    HALF = 500
    U16 = 200
    U32 = 300
    U8 = 100

class ConfigError(GObject.GEnum):
    OPEN = 0
    OPEN_ENOENT = 1
    PARSE = 3
    VERSION = 4
    WRITE = 2

class ConfigPathType(GObject.GEnum):
    DIR = 2
    DIR_LIST = 3
    FILE = 0
    FILE_LIST = 1

class ConvertDitherType(GObject.GEnum):
    FIXED = 3
    FS = 1
    FS_LOWBLEED = 2
    NONE = 0

class ConvertPaletteType(GObject.GEnum):
    CUSTOM = 3
    GENERATE = 0
    MONO = 2
    WEB = 1

class ConvolveType(GObject.GEnum):
    BLUR = 0
    SHARPEN = 1

class DesaturateMode(GObject.GEnum):
    AVERAGE = 2
    LIGHTNESS = 0
    LUMA = 1
    LUMINANCE = 3
    VALUE = 4

class DodgeBurnType(GObject.GEnum):
    BURN = 1
    DODGE = 0

class ExportReturn(GObject.GEnum):
    EXPORT = 1
    IGNORE = 0

class FileChooserAction(GObject.GEnum):
    ANY = -1
    CREATE_FOLDER = 3
    OPEN = 0
    SAVE = 1
    SELECT_FOLDER = 2

class FillType(GObject.GEnum):
    BACKGROUND = 1
    CIELAB_MIDDLE_GRAY = 2
    FOREGROUND = 0
    PATTERN = 5
    TRANSPARENT = 4
    WHITE = 3

class ForegroundExtractMode(GObject.GEnum):
    MATTING = 0

class GradientBlendColorSpace(GObject.GEnum):
    CIE_LAB = 2
    RGB_LINEAR = 1
    RGB_PERCEPTUAL = 0

class GradientSegmentColor(GObject.GEnum):
    HSV_CCW = 1
    HSV_CW = 2
    RGB = 0

class GradientSegmentType(GObject.GEnum):
    CURVED = 1
    LINEAR = 0
    SINE = 2
    SPHERE_DECREASING = 4
    SPHERE_INCREASING = 3
    STEP = 5

class GradientType(GObject.GEnum):
    BILINEAR = 1
    CONICAL_ASYMMETRIC = 5
    CONICAL_SYMMETRIC = 4
    LINEAR = 0
    RADIAL = 2
    SHAPEBURST_ANGULAR = 6
    SHAPEBURST_DIMPLED = 8
    SHAPEBURST_SPHERICAL = 7
    SPIRAL_ANTICLOCKWISE = 10
    SPIRAL_CLOCKWISE = 9
    SQUARE = 3

class GridStyle(GObject.GEnum):
    DOTS = 0
    DOUBLE_DASH = 3
    INTERSECTIONS = 1
    ON_OFF_DASH = 2
    SOLID = 4

class HistogramChannel(GObject.GEnum):
    ALPHA = 4
    BLUE = 3
    GREEN = 2
    LUMINANCE = 5
    RED = 1
    VALUE = 0

class HueRange(GObject.GEnum):
    ALL = 0
    BLUE = 5
    CYAN = 4
    GREEN = 3
    MAGENTA = 6
    RED = 1
    YELLOW = 2

class IconType(GObject.GEnum):
    ICON_NAME = 0
    IMAGE_FILE = 2
    PIXBUF = 1

class ImageBaseType(GObject.GEnum):
    GRAY = 1
    INDEXED = 2
    RGB = 0

class ImageType(GObject.GEnum):
    GRAYA_IMAGE = 3
    GRAY_IMAGE = 2
    INDEXEDA_IMAGE = 5
    INDEXED_IMAGE = 4
    RGBA_IMAGE = 1
    RGB_IMAGE = 0

class InkBlobType(GObject.GEnum):
    CIRCLE = 0
    DIAMOND = 2
    SQUARE = 1

class InterpolationType(GObject.GEnum):
    CUBIC = 2
    LINEAR = 1
    LOHALO = 4
    NOHALO = 3
    NONE = 0

class JoinStyle(GObject.GEnum):
    BEVEL = 2
    MITER = 0
    ROUND = 1

class LayerColorSpace(GObject.GEnum):
    AUTO = 0
    LAB = 3
    RGB_LINEAR = 1
    RGB_NON_LINEAR = 2
    RGB_PERCEPTUAL = 4

class LayerCompositeMode(GObject.GEnum):
    AUTO = 0
    CLIP_TO_BACKDROP = 2
    CLIP_TO_LAYER = 3
    INTERSECTION = 4
    UNION = 1

class LayerMode(GObject.GEnum):
    ADDITION = 33
    ADDITION_LEGACY = 7
    BEHIND = 29
    BEHIND_LEGACY = 2
    BURN = 43
    BURN_LEGACY = 17
    COLOR_ERASE = 57
    COLOR_ERASE_LEGACY = 22
    DARKEN_ONLY = 35
    DARKEN_ONLY_LEGACY = 9
    DIFFERENCE = 32
    DIFFERENCE_LEGACY = 6
    DISSOLVE = 1
    DIVIDE = 41
    DIVIDE_LEGACY = 15
    DODGE = 42
    DODGE_LEGACY = 16
    ERASE = 58
    EXCLUSION = 52
    GRAIN_EXTRACT = 46
    GRAIN_EXTRACT_LEGACY = 20
    GRAIN_MERGE = 47
    GRAIN_MERGE_LEGACY = 21
    HARDLIGHT = 44
    HARDLIGHT_LEGACY = 18
    HARD_MIX = 51
    HSL_COLOR = 39
    HSL_COLOR_LEGACY = 13
    HSV_HUE = 37
    HSV_HUE_LEGACY = 11
    HSV_SATURATION = 38
    HSV_SATURATION_LEGACY = 12
    HSV_VALUE = 40
    HSV_VALUE_LEGACY = 14
    LCH_CHROMA = 25
    LCH_COLOR = 26
    LCH_HUE = 24
    LCH_LIGHTNESS = 27
    LIGHTEN_ONLY = 36
    LIGHTEN_ONLY_LEGACY = 10
    LINEAR_BURN = 53
    LINEAR_LIGHT = 50
    LUMA_DARKEN_ONLY = 54
    LUMA_LIGHTEN_ONLY = 55
    LUMINANCE = 56
    MERGE = 59
    MULTIPLY = 30
    MULTIPLY_LEGACY = 3
    NORMAL = 28
    NORMAL_LEGACY = 0
    OVERLAY = 23
    OVERLAY_LEGACY = 5
    PASS_THROUGH = 61
    PIN_LIGHT = 49
    REPLACE = 62
    SCREEN = 31
    SCREEN_LEGACY = 4
    SOFTLIGHT = 45
    SOFTLIGHT_LEGACY = 19
    SPLIT = 60
    SUBTRACT = 34
    SUBTRACT_LEGACY = 8
    VIVID_LIGHT = 48

class MaskApplyMode(GObject.GEnum):
    APPLY = 0
    DISCARD = 1

class MergeType(GObject.GEnum):
    CLIP_TO_BOTTOM_LAYER = 2
    CLIP_TO_IMAGE = 1
    EXPAND_AS_NECESSARY = 0
    FLATTEN_IMAGE = 3

class MessageHandlerType(GObject.GEnum):
    CONSOLE = 1
    ERROR_CONSOLE = 2
    MESSAGE_BOX = 0

class MetadataColorspace(GObject.GEnum):
    ADOBERGB = 3
    SRGB = 2
    UNCALIBRATED = 1
    UNSPECIFIED = 0

class ModuleError(GObject.GEnum):
    MODULE_FAILED = 0

class ModuleState(GObject.GEnum):
    ERROR = 0
    LOADED = 1
    LOAD_FAILED = 2
    NOT_LOADED = 3

class OffsetType(GObject.GEnum):
    COLOR = 0
    TRANSPARENT = 1
    WRAP_AROUND = 2

class OrientationType(GObject.GEnum):
    HORIZONTAL = 0
    UNKNOWN = 2
    VERTICAL = 1

class PDBErrorHandler(GObject.GEnum):
    INTERNAL = 0
    PLUGIN = 1

class PDBProcType(GObject.GEnum):
    INTERNAL = 0
    PERSISTENT = 2
    PLUGIN = 1
    TEMPORARY = 3

class PDBStatusType(GObject.GEnum):
    CALLING_ERROR = 1
    CANCEL = 4
    EXECUTION_ERROR = 0
    PASS_THROUGH = 2
    SUCCESS = 3

class PaintApplicationMode(GObject.GEnum):
    CONSTANT = 0
    INCREMENTAL = 1

class PathStrokeType(GObject.GEnum):
    BEZIER = 0

class PixbufTransparency(GObject.GEnum):
    KEEP_ALPHA = 0
    LARGE_CHECKS = 2
    SMALL_CHECKS = 1

class Precision(GObject.GEnum):
    DOUBLE_LINEAR = 700
    DOUBLE_NON_LINEAR = 750
    DOUBLE_PERCEPTUAL = 775
    FLOAT_LINEAR = 600
    FLOAT_NON_LINEAR = 650
    FLOAT_PERCEPTUAL = 675
    HALF_LINEAR = 500
    HALF_NON_LINEAR = 550
    HALF_PERCEPTUAL = 575
    U16_LINEAR = 200
    U16_NON_LINEAR = 250
    U16_PERCEPTUAL = 275
    U32_LINEAR = 300
    U32_NON_LINEAR = 350
    U32_PERCEPTUAL = 375
    U8_LINEAR = 100
    U8_NON_LINEAR = 150
    U8_PERCEPTUAL = 175

class ProgressCommand(GObject.GEnum):
    END = 1
    GET_WINDOW = 5
    PULSE = 4
    SET_TEXT = 2
    SET_VALUE = 3
    START = 0

class RepeatMode(GObject.GEnum):
    NONE = 0
    SAWTOOTH = 2
    TRIANGULAR = 3
    TRUNCATE = 1

class RotationType(GObject.GEnum):
    DEGREES180 = 1
    DEGREES270 = 2
    DEGREES90 = 0

class RunMode(GObject.GEnum):
    INTERACTIVE = 0
    NONINTERACTIVE = 1
    WITH_LAST_VALS = 2

class SelectCriterion(GObject.GEnum):
    ALPHA = 10
    COMPOSITE = 0
    HSV_HUE = 4
    HSV_SATURATION = 5
    HSV_VALUE = 6
    LCH_CHROMA = 8
    LCH_HUE = 9
    LCH_LIGHTNESS = 7
    RGB_BLUE = 3
    RGB_GREEN = 2
    RGB_RED = 1

class SizeType(GObject.GEnum):
    PIXELS = 0
    POINTS = 1

class StackTraceMode(GObject.GEnum):
    ALWAYS = 2
    NEVER = 0
    QUERY = 1

class StrokeMethod(GObject.GEnum):
    LINE = 0
    PAINT_METHOD = 1

class TextDirection(GObject.GEnum):
    LTR = 0
    RTL = 1
    TTB_LTR = 4
    TTB_LTR_UPRIGHT = 5
    TTB_RTL = 2
    TTB_RTL_UPRIGHT = 3

class TextHintStyle(GObject.GEnum):
    FULL = 3
    MEDIUM = 2
    NONE = 0
    SLIGHT = 1

class TextJustification(GObject.GEnum):
    CENTER = 2
    FILL = 3
    LEFT = 0
    RIGHT = 1

class TransferMode(GObject.GEnum):
    HIGHLIGHTS = 2
    MIDTONES = 1
    SHADOWS = 0

class TransformDirection(GObject.GEnum):
    BACKWARD = 1
    FORWARD = 0

class TransformResize(GObject.GEnum):
    ADJUST = 0
    CLIP = 1
    CROP = 2
    CROP_WITH_ASPECT = 3

class UnitID(GObject.GEnum):
    END = 5
    INCH = 1
    MM = 2
    PERCENT = 65536
    PICA = 4
    PIXEL = 0
    POINT = 3
